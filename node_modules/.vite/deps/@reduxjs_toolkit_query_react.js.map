{"version":3,"file":"@reduxjs_toolkit_query_react.js","names":["ENDPOINT_QUERY","ENDPOINT_MUTATION","ENDPOINT_INFINITEQUERY","isQueryDefinition","isMutationDefinition","isInfiniteQueryDefinition","createNextState","safeAssign","createApi","cache","useLayoutEffect","useEffect","useDispatch","createSelector","useSelector","useStore","rrBatch","rrUseDispatch","rrUseSelector","rrUseStore","_createSelector","Provider"],"sources":["../../@standard-schema/utils/dist/index.js","../../@reduxjs/toolkit/dist/query/rtk-query.modern.mjs","../../@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs"],"sourcesContent":["// src/getDotPath/getDotPath.ts\nfunction getDotPath(issue) {\n  if (issue.path?.length) {\n    let dotPath = \"\";\n    for (const item of issue.path) {\n      const key = typeof item === \"object\" ? item.key : item;\n      if (typeof key === \"string\" || typeof key === \"number\") {\n        if (dotPath) {\n          dotPath += `.${key}`;\n        } else {\n          dotPath += key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return dotPath;\n  }\n  return null;\n}\n\n// src/SchemaError/SchemaError.ts\nvar SchemaError = class extends Error {\n  /**\n   * The schema issues.\n   */\n  issues;\n  /**\n   * Creates a schema error with useful information.\n   *\n   * @param issues The schema issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"SchemaError\";\n    this.issues = issues;\n  }\n};\nexport {\n  SchemaError,\n  getDotPath\n};\n","// src/query/core/apiState.ts\nvar QueryStatus = /* @__PURE__ */ ((QueryStatus7) => {\n  QueryStatus7[\"uninitialized\"] = \"uninitialized\";\n  QueryStatus7[\"pending\"] = \"pending\";\n  QueryStatus7[\"fulfilled\"] = \"fulfilled\";\n  QueryStatus7[\"rejected\"] = \"rejected\";\n  return QueryStatus7;\n})(QueryStatus || {});\nvar STATUS_UNINITIALIZED = \"uninitialized\" /* uninitialized */;\nvar STATUS_PENDING = \"pending\" /* pending */;\nvar STATUS_FULFILLED = \"fulfilled\" /* fulfilled */;\nvar STATUS_REJECTED = \"rejected\" /* rejected */;\nfunction getRequestStatusFlags(status) {\n  return {\n    status,\n    isUninitialized: status === STATUS_UNINITIALIZED,\n    isLoading: status === STATUS_PENDING,\n    isSuccess: status === STATUS_FULFILLED,\n    isError: status === STATUS_REJECTED\n  };\n}\n\n// src/query/core/rtkImports.ts\nimport { createAction, createSlice, createSelector, createAsyncThunk, combineReducers, createNextState, isAnyOf, isAllOf, isAction, isPending, isRejected, isFulfilled, isRejectedWithValue, isAsyncThunkAction, prepareAutoBatched, SHOULD_AUTOBATCH, isPlainObject, nanoid } from \"@reduxjs/toolkit\";\n\n// src/query/utils/copyWithStructuralSharing.ts\nvar isPlainObject2 = isPlainObject;\nfunction copyWithStructuralSharing(oldObj, newObj) {\n  if (oldObj === newObj || !(isPlainObject2(oldObj) && isPlainObject2(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {\n    return newObj;\n  }\n  const newKeys = Object.keys(newObj);\n  const oldKeys = Object.keys(oldObj);\n  let isSameObject = newKeys.length === oldKeys.length;\n  const mergeObj = Array.isArray(newObj) ? [] : {};\n  for (const key of newKeys) {\n    mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);\n    if (isSameObject) isSameObject = oldObj[key] === mergeObj[key];\n  }\n  return isSameObject ? oldObj : mergeObj;\n}\n\n// src/query/utils/filterMap.ts\nfunction filterMap(array, predicate, mapper) {\n  return array.reduce((acc, item, i) => {\n    if (predicate(item, i)) {\n      acc.push(mapper(item, i));\n    }\n    return acc;\n  }, []).flat();\n}\n\n// src/query/utils/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n  return new RegExp(`(^|:)//`).test(url);\n}\n\n// src/query/utils/isDocumentVisible.ts\nfunction isDocumentVisible() {\n  if (typeof document === \"undefined\") {\n    return true;\n  }\n  return document.visibilityState !== \"hidden\";\n}\n\n// src/query/utils/isNotNullish.ts\nfunction isNotNullish(v) {\n  return v != null;\n}\nfunction filterNullishValues(map) {\n  return [...map?.values() ?? []].filter(isNotNullish);\n}\n\n// src/query/utils/isOnline.ts\nfunction isOnline() {\n  return typeof navigator === \"undefined\" ? true : navigator.onLine === void 0 ? true : navigator.onLine;\n}\n\n// src/query/utils/joinUrls.ts\nvar withoutTrailingSlash = (url) => url.replace(/\\/$/, \"\");\nvar withoutLeadingSlash = (url) => url.replace(/^\\//, \"\");\nfunction joinUrls(base, url) {\n  if (!base) {\n    return url;\n  }\n  if (!url) {\n    return base;\n  }\n  if (isAbsoluteUrl(url)) {\n    return url;\n  }\n  const delimiter = base.endsWith(\"/\") || !url.startsWith(\"?\") ? \"/\" : \"\";\n  base = withoutTrailingSlash(base);\n  url = withoutLeadingSlash(url);\n  return `${base}${delimiter}${url}`;\n}\n\n// src/query/utils/getOrInsert.ts\nfunction getOrInsertComputed(map, key, compute) {\n  if (map.has(key)) return map.get(key);\n  return map.set(key, compute(key)).get(key);\n}\nvar createNewMap = () => /* @__PURE__ */ new Map();\n\n// src/query/fetchBaseQuery.ts\nvar defaultFetchFn = (...args) => fetch(...args);\nvar defaultValidateStatus = (response) => response.status >= 200 && response.status <= 299;\nvar defaultIsJsonContentType = (headers) => (\n  /*applicat*/\n  /ion\\/(vnd\\.api\\+)?json/.test(headers.get(\"content-type\") || \"\")\n);\nfunction stripUndefined(obj) {\n  if (!isPlainObject(obj)) {\n    return obj;\n  }\n  const copy = {\n    ...obj\n  };\n  for (const [k, v] of Object.entries(copy)) {\n    if (v === void 0) delete copy[k];\n  }\n  return copy;\n}\nvar isJsonifiable = (body) => typeof body === \"object\" && (isPlainObject(body) || Array.isArray(body) || typeof body.toJSON === \"function\");\nfunction fetchBaseQuery({\n  baseUrl,\n  prepareHeaders = (x) => x,\n  fetchFn = defaultFetchFn,\n  paramsSerializer,\n  isJsonContentType = defaultIsJsonContentType,\n  jsonContentType = \"application/json\",\n  jsonReplacer,\n  timeout: defaultTimeout,\n  responseHandler: globalResponseHandler,\n  validateStatus: globalValidateStatus,\n  ...baseFetchOptions\n} = {}) {\n  if (typeof fetch === \"undefined\" && fetchFn === defaultFetchFn) {\n    console.warn(\"Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.\");\n  }\n  return async (arg, api, extraOptions) => {\n    const {\n      getState,\n      extra,\n      endpoint,\n      forced,\n      type\n    } = api;\n    let meta;\n    let {\n      url,\n      headers = new Headers(baseFetchOptions.headers),\n      params = void 0,\n      responseHandler = globalResponseHandler ?? \"json\",\n      validateStatus = globalValidateStatus ?? defaultValidateStatus,\n      timeout = defaultTimeout,\n      ...rest\n    } = typeof arg == \"string\" ? {\n      url: arg\n    } : arg;\n    let abortController, signal = api.signal;\n    if (timeout) {\n      abortController = new AbortController();\n      api.signal.addEventListener(\"abort\", abortController.abort);\n      signal = abortController.signal;\n    }\n    let config = {\n      ...baseFetchOptions,\n      signal,\n      ...rest\n    };\n    headers = new Headers(stripUndefined(headers));\n    config.headers = await prepareHeaders(headers, {\n      getState,\n      arg,\n      extra,\n      endpoint,\n      forced,\n      type,\n      extraOptions\n    }) || headers;\n    const bodyIsJsonifiable = isJsonifiable(config.body);\n    if (config.body != null && !bodyIsJsonifiable && typeof config.body !== \"string\") {\n      config.headers.delete(\"content-type\");\n    }\n    if (!config.headers.has(\"content-type\") && bodyIsJsonifiable) {\n      config.headers.set(\"content-type\", jsonContentType);\n    }\n    if (bodyIsJsonifiable && isJsonContentType(config.headers)) {\n      config.body = JSON.stringify(config.body, jsonReplacer);\n    }\n    if (!config.headers.has(\"accept\")) {\n      if (responseHandler === \"json\") {\n        config.headers.set(\"accept\", \"application/json\");\n      } else if (responseHandler === \"text\") {\n        config.headers.set(\"accept\", \"text/plain, text/html, */*\");\n      }\n    }\n    if (params) {\n      const divider = ~url.indexOf(\"?\") ? \"&\" : \"?\";\n      const query = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));\n      url += divider + query;\n    }\n    url = joinUrls(baseUrl, url);\n    const request = new Request(url, config);\n    const requestClone = new Request(url, config);\n    meta = {\n      request: requestClone\n    };\n    let response, timedOut = false, timeoutId = abortController && setTimeout(() => {\n      timedOut = true;\n      abortController.abort();\n    }, timeout);\n    try {\n      response = await fetchFn(request);\n    } catch (e) {\n      return {\n        error: {\n          status: timedOut ? \"TIMEOUT_ERROR\" : \"FETCH_ERROR\",\n          error: String(e)\n        },\n        meta\n      };\n    } finally {\n      if (timeoutId) clearTimeout(timeoutId);\n      abortController?.signal.removeEventListener(\"abort\", abortController.abort);\n    }\n    const responseClone = response.clone();\n    meta.response = responseClone;\n    let resultData;\n    let responseText = \"\";\n    try {\n      let handleResponseError;\n      await Promise.all([\n        handleResponse(response, responseHandler).then((r) => resultData = r, (e) => handleResponseError = e),\n        // see https://github.com/node-fetch/node-fetch/issues/665#issuecomment-538995182\n        // we *have* to \"use up\" both streams at the same time or they will stop running in node-fetch scenarios\n        responseClone.text().then((r) => responseText = r, () => {\n        })\n      ]);\n      if (handleResponseError) throw handleResponseError;\n    } catch (e) {\n      return {\n        error: {\n          status: \"PARSING_ERROR\",\n          originalStatus: response.status,\n          data: responseText,\n          error: String(e)\n        },\n        meta\n      };\n    }\n    return validateStatus(response, resultData) ? {\n      data: resultData,\n      meta\n    } : {\n      error: {\n        status: response.status,\n        data: resultData\n      },\n      meta\n    };\n  };\n  async function handleResponse(response, responseHandler) {\n    if (typeof responseHandler === \"function\") {\n      return responseHandler(response);\n    }\n    if (responseHandler === \"content-type\") {\n      responseHandler = isJsonContentType(response.headers) ? \"json\" : \"text\";\n    }\n    if (responseHandler === \"json\") {\n      const text = await response.text();\n      return text.length ? JSON.parse(text) : null;\n    }\n    return response.text();\n  }\n}\n\n// src/query/HandledError.ts\nvar HandledError = class {\n  constructor(value, meta = void 0) {\n    this.value = value;\n    this.meta = meta;\n  }\n};\n\n// src/query/retry.ts\nasync function defaultBackoff(attempt = 0, maxRetries = 5, signal) {\n  const attempts = Math.min(attempt, maxRetries);\n  const timeout = ~~((Math.random() + 0.4) * (300 << attempts));\n  await new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => resolve(), timeout);\n    if (signal) {\n      const abortHandler = () => {\n        clearTimeout(timeoutId);\n        reject(new Error(\"Aborted\"));\n      };\n      if (signal.aborted) {\n        clearTimeout(timeoutId);\n        reject(new Error(\"Aborted\"));\n      } else {\n        signal.addEventListener(\"abort\", abortHandler, {\n          once: true\n        });\n      }\n    }\n  });\n}\nfunction fail(error, meta) {\n  throw Object.assign(new HandledError({\n    error,\n    meta\n  }), {\n    throwImmediately: true\n  });\n}\nfunction failIfAborted(signal) {\n  if (signal.aborted) {\n    fail({\n      status: \"CUSTOM_ERROR\",\n      error: \"Aborted\"\n    });\n  }\n}\nvar EMPTY_OPTIONS = {};\nvar retryWithBackoff = (baseQuery, defaultOptions) => async (args, api, extraOptions) => {\n  const possibleMaxRetries = [5, (defaultOptions || EMPTY_OPTIONS).maxRetries, (extraOptions || EMPTY_OPTIONS).maxRetries].filter((x) => x !== void 0);\n  const [maxRetries] = possibleMaxRetries.slice(-1);\n  const defaultRetryCondition = (_, __, {\n    attempt\n  }) => attempt <= maxRetries;\n  const options = {\n    maxRetries,\n    backoff: defaultBackoff,\n    retryCondition: defaultRetryCondition,\n    ...defaultOptions,\n    ...extraOptions\n  };\n  let retry2 = 0;\n  while (true) {\n    failIfAborted(api.signal);\n    try {\n      const result = await baseQuery(args, api, extraOptions);\n      if (result.error) {\n        throw new HandledError(result);\n      }\n      return result;\n    } catch (e) {\n      retry2++;\n      if (e.throwImmediately) {\n        if (e instanceof HandledError) {\n          return e.value;\n        }\n        throw e;\n      }\n      if (e instanceof HandledError) {\n        if (!options.retryCondition(e.value.error, args, {\n          attempt: retry2,\n          baseQueryApi: api,\n          extraOptions\n        })) {\n          return e.value;\n        }\n      } else {\n        if (retry2 > options.maxRetries) {\n          return {\n            error: e\n          };\n        }\n      }\n      failIfAborted(api.signal);\n      try {\n        await options.backoff(retry2, options.maxRetries, api.signal);\n      } catch (backoffError) {\n        failIfAborted(api.signal);\n        throw backoffError;\n      }\n    }\n  }\n};\nvar retry = /* @__PURE__ */ Object.assign(retryWithBackoff, {\n  fail\n});\n\n// src/query/core/setupListeners.ts\nvar INTERNAL_PREFIX = \"__rtkq/\";\nvar ONLINE = \"online\";\nvar OFFLINE = \"offline\";\nvar FOCUS = \"focus\";\nvar FOCUSED = \"focused\";\nvar VISIBILITYCHANGE = \"visibilitychange\";\nvar onFocus = /* @__PURE__ */ createAction(`${INTERNAL_PREFIX}${FOCUSED}`);\nvar onFocusLost = /* @__PURE__ */ createAction(`${INTERNAL_PREFIX}un${FOCUSED}`);\nvar onOnline = /* @__PURE__ */ createAction(`${INTERNAL_PREFIX}${ONLINE}`);\nvar onOffline = /* @__PURE__ */ createAction(`${INTERNAL_PREFIX}${OFFLINE}`);\nvar actions = {\n  onFocus,\n  onFocusLost,\n  onOnline,\n  onOffline\n};\nvar initialized = false;\nfunction setupListeners(dispatch, customHandler) {\n  function defaultHandler() {\n    const [handleFocus, handleFocusLost, handleOnline, handleOffline] = [onFocus, onFocusLost, onOnline, onOffline].map((action) => () => dispatch(action()));\n    const handleVisibilityChange = () => {\n      if (window.document.visibilityState === \"visible\") {\n        handleFocus();\n      } else {\n        handleFocusLost();\n      }\n    };\n    let unsubscribe = () => {\n      initialized = false;\n    };\n    if (!initialized) {\n      if (typeof window !== \"undefined\" && window.addEventListener) {\n        let updateListeners2 = function(add) {\n          Object.entries(handlers).forEach(([event, handler]) => {\n            if (add) {\n              window.addEventListener(event, handler, false);\n            } else {\n              window.removeEventListener(event, handler);\n            }\n          });\n        };\n        var updateListeners = updateListeners2;\n        const handlers = {\n          [FOCUS]: handleFocus,\n          [VISIBILITYCHANGE]: handleVisibilityChange,\n          [ONLINE]: handleOnline,\n          [OFFLINE]: handleOffline\n        };\n        updateListeners2(true);\n        initialized = true;\n        unsubscribe = () => {\n          updateListeners2(false);\n          initialized = false;\n        };\n      }\n    }\n    return unsubscribe;\n  }\n  return customHandler ? customHandler(dispatch, actions) : defaultHandler();\n}\n\n// src/query/endpointDefinitions.ts\nvar ENDPOINT_QUERY = \"query\" /* query */;\nvar ENDPOINT_MUTATION = \"mutation\" /* mutation */;\nvar ENDPOINT_INFINITEQUERY = \"infinitequery\" /* infinitequery */;\nfunction isQueryDefinition(e) {\n  return e.type === ENDPOINT_QUERY;\n}\nfunction isMutationDefinition(e) {\n  return e.type === ENDPOINT_MUTATION;\n}\nfunction isInfiniteQueryDefinition(e) {\n  return e.type === ENDPOINT_INFINITEQUERY;\n}\nfunction isAnyQueryDefinition(e) {\n  return isQueryDefinition(e) || isInfiniteQueryDefinition(e);\n}\nfunction calculateProvidedBy(description, result, error, queryArg, meta, assertTagTypes) {\n  const finalDescription = isFunction(description) ? description(result, error, queryArg, meta) : description;\n  if (finalDescription) {\n    return filterMap(finalDescription, isNotNullish, (tag) => assertTagTypes(expandTagDescription(tag)));\n  }\n  return [];\n}\nfunction isFunction(t) {\n  return typeof t === \"function\";\n}\nfunction expandTagDescription(description) {\n  return typeof description === \"string\" ? {\n    type: description\n  } : description;\n}\n\n// src/query/utils/immerImports.ts\nimport { current, isDraft, applyPatches, original, isDraftable, produceWithPatches, enablePatches } from \"immer\";\n\n// src/query/core/buildInitiate.ts\nimport { formatProdErrorMessage as _formatProdErrorMessage } from \"@reduxjs/toolkit\";\n\n// src/tsHelpers.ts\nfunction asSafePromise(promise, fallback) {\n  return promise.catch(fallback);\n}\n\n// src/query/apiTypes.ts\nvar getEndpointDefinition = (context, endpointName) => context.endpointDefinitions[endpointName];\n\n// src/query/core/buildInitiate.ts\nvar forceQueryFnSymbol = Symbol(\"forceQueryFn\");\nvar isUpsertQuery = (arg) => typeof arg[forceQueryFnSymbol] === \"function\";\nfunction buildInitiate({\n  serializeQueryArgs,\n  queryThunk,\n  infiniteQueryThunk,\n  mutationThunk,\n  api,\n  context,\n  getInternalState\n}) {\n  const getRunningQueries = (dispatch) => getInternalState(dispatch)?.runningQueries;\n  const getRunningMutations = (dispatch) => getInternalState(dispatch)?.runningMutations;\n  const {\n    unsubscribeQueryResult,\n    removeMutationResult,\n    updateSubscriptionOptions\n  } = api.internalActions;\n  return {\n    buildInitiateQuery,\n    buildInitiateInfiniteQuery,\n    buildInitiateMutation,\n    getRunningQueryThunk,\n    getRunningMutationThunk,\n    getRunningQueriesThunk,\n    getRunningMutationsThunk\n  };\n  function getRunningQueryThunk(endpointName, queryArgs) {\n    return (dispatch) => {\n      const endpointDefinition = getEndpointDefinition(context, endpointName);\n      const queryCacheKey = serializeQueryArgs({\n        queryArgs,\n        endpointDefinition,\n        endpointName\n      });\n      return getRunningQueries(dispatch)?.get(queryCacheKey);\n    };\n  }\n  function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {\n    return (dispatch) => {\n      return getRunningMutations(dispatch)?.get(fixedCacheKeyOrRequestId);\n    };\n  }\n  function getRunningQueriesThunk() {\n    return (dispatch) => filterNullishValues(getRunningQueries(dispatch));\n  }\n  function getRunningMutationsThunk() {\n    return (dispatch) => filterNullishValues(getRunningMutations(dispatch));\n  }\n  function middlewareWarning(dispatch) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (middlewareWarning.triggered) return;\n      const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());\n      middlewareWarning.triggered = true;\n      if (typeof returnedValue !== \"object\" || typeof returnedValue?.type === \"string\") {\n        throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage(34) : `Warning: Middleware for RTK-Query API at reducerPath \"${api.reducerPath}\" has not been added to the store.\nYou must add the middleware for RTK-Query to function correctly!`);\n      }\n    }\n  }\n  function buildInitiateAnyQuery(endpointName, endpointDefinition) {\n    const queryAction = (arg, {\n      subscribe = true,\n      forceRefetch,\n      subscriptionOptions,\n      [forceQueryFnSymbol]: forceQueryFn,\n      ...rest\n    } = {}) => (dispatch, getState) => {\n      const queryCacheKey = serializeQueryArgs({\n        queryArgs: arg,\n        endpointDefinition,\n        endpointName\n      });\n      let thunk;\n      const commonThunkArgs = {\n        ...rest,\n        type: ENDPOINT_QUERY,\n        subscribe,\n        forceRefetch,\n        subscriptionOptions,\n        endpointName,\n        originalArgs: arg,\n        queryCacheKey,\n        [forceQueryFnSymbol]: forceQueryFn\n      };\n      if (isQueryDefinition(endpointDefinition)) {\n        thunk = queryThunk(commonThunkArgs);\n      } else {\n        const {\n          direction,\n          initialPageParam\n        } = rest;\n        thunk = infiniteQueryThunk({\n          ...commonThunkArgs,\n          // Supply these even if undefined. This helps with a field existence\n          // check over in `buildSlice.ts`\n          direction,\n          initialPageParam\n        });\n      }\n      const selector = api.endpoints[endpointName].select(arg);\n      const thunkResult = dispatch(thunk);\n      const stateAfter = selector(getState());\n      middlewareWarning(dispatch);\n      const {\n        requestId,\n        abort\n      } = thunkResult;\n      const skippedSynchronously = stateAfter.requestId !== requestId;\n      const runningQuery = getRunningQueries(dispatch)?.get(queryCacheKey);\n      const selectFromState = () => selector(getState());\n      const statePromise = Object.assign(forceQueryFn ? (\n        // a query has been forced (upsertQueryData)\n        // -> we want to resolve it once data has been written with the data that will be written\n        thunkResult.then(selectFromState)\n      ) : skippedSynchronously && !runningQuery ? (\n        // a query has been skipped due to a condition and we do not have any currently running query\n        // -> we want to resolve it immediately with the current data\n        Promise.resolve(stateAfter)\n      ) : (\n        // query just started or one is already in flight\n        // -> wait for the running query, then resolve with data from after that\n        Promise.all([runningQuery, thunkResult]).then(selectFromState)\n      ), {\n        arg,\n        requestId,\n        subscriptionOptions,\n        queryCacheKey,\n        abort,\n        async unwrap() {\n          const result = await statePromise;\n          if (result.isError) {\n            throw result.error;\n          }\n          return result.data;\n        },\n        refetch: () => dispatch(queryAction(arg, {\n          subscribe: false,\n          forceRefetch: true\n        })),\n        unsubscribe() {\n          if (subscribe) dispatch(unsubscribeQueryResult({\n            queryCacheKey,\n            requestId\n          }));\n        },\n        updateSubscriptionOptions(options) {\n          statePromise.subscriptionOptions = options;\n          dispatch(updateSubscriptionOptions({\n            endpointName,\n            requestId,\n            queryCacheKey,\n            options\n          }));\n        }\n      });\n      if (!runningQuery && !skippedSynchronously && !forceQueryFn) {\n        const runningQueries = getRunningQueries(dispatch);\n        runningQueries.set(queryCacheKey, statePromise);\n        statePromise.then(() => {\n          runningQueries.delete(queryCacheKey);\n        });\n      }\n      return statePromise;\n    };\n    return queryAction;\n  }\n  function buildInitiateQuery(endpointName, endpointDefinition) {\n    const queryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);\n    return queryAction;\n  }\n  function buildInitiateInfiniteQuery(endpointName, endpointDefinition) {\n    const infiniteQueryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);\n    return infiniteQueryAction;\n  }\n  function buildInitiateMutation(endpointName) {\n    return (arg, {\n      track = true,\n      fixedCacheKey\n    } = {}) => (dispatch, getState) => {\n      const thunk = mutationThunk({\n        type: \"mutation\",\n        endpointName,\n        originalArgs: arg,\n        track,\n        fixedCacheKey\n      });\n      const thunkResult = dispatch(thunk);\n      middlewareWarning(dispatch);\n      const {\n        requestId,\n        abort,\n        unwrap\n      } = thunkResult;\n      const returnValuePromise = asSafePromise(thunkResult.unwrap().then((data) => ({\n        data\n      })), (error) => ({\n        error\n      }));\n      const reset = () => {\n        dispatch(removeMutationResult({\n          requestId,\n          fixedCacheKey\n        }));\n      };\n      const ret = Object.assign(returnValuePromise, {\n        arg: thunkResult.arg,\n        requestId,\n        abort,\n        unwrap,\n        reset\n      });\n      const runningMutations = getRunningMutations(dispatch);\n      runningMutations.set(requestId, ret);\n      ret.then(() => {\n        runningMutations.delete(requestId);\n      });\n      if (fixedCacheKey) {\n        runningMutations.set(fixedCacheKey, ret);\n        ret.then(() => {\n          if (runningMutations.get(fixedCacheKey) === ret) {\n            runningMutations.delete(fixedCacheKey);\n          }\n        });\n      }\n      return ret;\n    };\n  }\n}\n\n// src/query/standardSchema.ts\nimport { SchemaError } from \"@standard-schema/utils\";\nvar NamedSchemaError = class extends SchemaError {\n  constructor(issues, value, schemaName, _bqMeta) {\n    super(issues);\n    this.value = value;\n    this.schemaName = schemaName;\n    this._bqMeta = _bqMeta;\n  }\n};\nvar shouldSkip = (skipSchemaValidation, schemaName) => Array.isArray(skipSchemaValidation) ? skipSchemaValidation.includes(schemaName) : !!skipSchemaValidation;\nasync function parseWithSchema(schema, data, schemaName, bqMeta) {\n  const result = await schema[\"~standard\"].validate(data);\n  if (result.issues) {\n    throw new NamedSchemaError(result.issues, data, schemaName, bqMeta);\n  }\n  return result.value;\n}\n\n// src/query/core/buildThunks.ts\nfunction defaultTransformResponse(baseQueryReturnValue) {\n  return baseQueryReturnValue;\n}\nvar addShouldAutoBatch = (arg = {}) => {\n  return {\n    ...arg,\n    [SHOULD_AUTOBATCH]: true\n  };\n};\nfunction buildThunks({\n  reducerPath,\n  baseQuery,\n  context: {\n    endpointDefinitions\n  },\n  serializeQueryArgs,\n  api,\n  assertTagType,\n  selectors,\n  onSchemaFailure,\n  catchSchemaFailure: globalCatchSchemaFailure,\n  skipSchemaValidation: globalSkipSchemaValidation\n}) {\n  const patchQueryData = (endpointName, arg, patches, updateProvided) => (dispatch, getState) => {\n    const endpointDefinition = endpointDefinitions[endpointName];\n    const queryCacheKey = serializeQueryArgs({\n      queryArgs: arg,\n      endpointDefinition,\n      endpointName\n    });\n    dispatch(api.internalActions.queryResultPatched({\n      queryCacheKey,\n      patches\n    }));\n    if (!updateProvided) {\n      return;\n    }\n    const newValue = api.endpoints[endpointName].select(arg)(\n      // Work around TS 4.1 mismatch\n      getState()\n    );\n    const providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, arg, {}, assertTagType);\n    dispatch(api.internalActions.updateProvidedBy([{\n      queryCacheKey,\n      providedTags\n    }]));\n  };\n  function addToStart(items, item, max = 0) {\n    const newItems = [item, ...items];\n    return max && newItems.length > max ? newItems.slice(0, -1) : newItems;\n  }\n  function addToEnd(items, item, max = 0) {\n    const newItems = [...items, item];\n    return max && newItems.length > max ? newItems.slice(1) : newItems;\n  }\n  const updateQueryData = (endpointName, arg, updateRecipe, updateProvided = true) => (dispatch, getState) => {\n    const endpointDefinition = api.endpoints[endpointName];\n    const currentState = endpointDefinition.select(arg)(\n      // Work around TS 4.1 mismatch\n      getState()\n    );\n    const ret = {\n      patches: [],\n      inversePatches: [],\n      undo: () => dispatch(api.util.patchQueryData(endpointName, arg, ret.inversePatches, updateProvided))\n    };\n    if (currentState.status === STATUS_UNINITIALIZED) {\n      return ret;\n    }\n    let newValue;\n    if (\"data\" in currentState) {\n      if (isDraftable(currentState.data)) {\n        const [value, patches, inversePatches] = produceWithPatches(currentState.data, updateRecipe);\n        ret.patches.push(...patches);\n        ret.inversePatches.push(...inversePatches);\n        newValue = value;\n      } else {\n        newValue = updateRecipe(currentState.data);\n        ret.patches.push({\n          op: \"replace\",\n          path: [],\n          value: newValue\n        });\n        ret.inversePatches.push({\n          op: \"replace\",\n          path: [],\n          value: currentState.data\n        });\n      }\n    }\n    if (ret.patches.length === 0) {\n      return ret;\n    }\n    dispatch(api.util.patchQueryData(endpointName, arg, ret.patches, updateProvided));\n    return ret;\n  };\n  const upsertQueryData = (endpointName, arg, value) => (dispatch) => {\n    const res = dispatch(api.endpoints[endpointName].initiate(arg, {\n      subscribe: false,\n      forceRefetch: true,\n      [forceQueryFnSymbol]: () => ({\n        data: value\n      })\n    }));\n    return res;\n  };\n  const getTransformCallbackForEndpoint = (endpointDefinition, transformFieldName) => {\n    return endpointDefinition.query && endpointDefinition[transformFieldName] ? endpointDefinition[transformFieldName] : defaultTransformResponse;\n  };\n  const executeEndpoint = async (arg, {\n    signal,\n    abort,\n    rejectWithValue,\n    fulfillWithValue,\n    dispatch,\n    getState,\n    extra\n  }) => {\n    const endpointDefinition = endpointDefinitions[arg.endpointName];\n    const {\n      metaSchema,\n      skipSchemaValidation = globalSkipSchemaValidation\n    } = endpointDefinition;\n    const isQuery = arg.type === ENDPOINT_QUERY;\n    try {\n      let transformResponse = defaultTransformResponse;\n      const baseQueryApi = {\n        signal,\n        abort,\n        dispatch,\n        getState,\n        extra,\n        endpoint: arg.endpointName,\n        type: arg.type,\n        forced: isQuery ? isForcedQuery(arg, getState()) : void 0,\n        queryCacheKey: isQuery ? arg.queryCacheKey : void 0\n      };\n      const forceQueryFn = isQuery ? arg[forceQueryFnSymbol] : void 0;\n      let finalQueryReturnValue;\n      const fetchPage = async (data, param, maxPages, previous) => {\n        if (param == null && data.pages.length) {\n          return Promise.resolve({\n            data\n          });\n        }\n        const finalQueryArg = {\n          queryArg: arg.originalArgs,\n          pageParam: param\n        };\n        const pageResponse = await executeRequest(finalQueryArg);\n        const addTo = previous ? addToStart : addToEnd;\n        return {\n          data: {\n            pages: addTo(data.pages, pageResponse.data, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          },\n          meta: pageResponse.meta\n        };\n      };\n      async function executeRequest(finalQueryArg) {\n        let result;\n        const {\n          extraOptions,\n          argSchema,\n          rawResponseSchema,\n          responseSchema\n        } = endpointDefinition;\n        if (argSchema && !shouldSkip(skipSchemaValidation, \"arg\")) {\n          finalQueryArg = await parseWithSchema(\n            argSchema,\n            finalQueryArg,\n            \"argSchema\",\n            {}\n            // we don't have a meta yet, so we can't pass it\n          );\n        }\n        if (forceQueryFn) {\n          result = forceQueryFn();\n        } else if (endpointDefinition.query) {\n          transformResponse = getTransformCallbackForEndpoint(endpointDefinition, \"transformResponse\");\n          result = await baseQuery(endpointDefinition.query(finalQueryArg), baseQueryApi, extraOptions);\n        } else {\n          result = await endpointDefinition.queryFn(finalQueryArg, baseQueryApi, extraOptions, (arg2) => baseQuery(arg2, baseQueryApi, extraOptions));\n        }\n        if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\n          const what = endpointDefinition.query ? \"`baseQuery`\" : \"`queryFn`\";\n          let err;\n          if (!result) {\n            err = `${what} did not return anything.`;\n          } else if (typeof result !== \"object\") {\n            err = `${what} did not return an object.`;\n          } else if (result.error && result.data) {\n            err = `${what} returned an object containing both \\`error\\` and \\`result\\`.`;\n          } else if (result.error === void 0 && result.data === void 0) {\n            err = `${what} returned an object containing neither a valid \\`error\\` and \\`result\\`. At least one of them should not be \\`undefined\\``;\n          } else {\n            for (const key of Object.keys(result)) {\n              if (key !== \"error\" && key !== \"data\" && key !== \"meta\") {\n                err = `The object returned by ${what} has the unknown property ${key}.`;\n                break;\n              }\n            }\n          }\n          if (err) {\n            console.error(`Error encountered handling the endpoint ${arg.endpointName}.\n                  ${err}\n                  It needs to return an object with either the shape \\`{ data: <value> }\\` or \\`{ error: <value> }\\` that may contain an optional \\`meta\\` property.\n                  Object returned was:`, result);\n          }\n        }\n        if (result.error) throw new HandledError(result.error, result.meta);\n        let {\n          data\n        } = result;\n        if (rawResponseSchema && !shouldSkip(skipSchemaValidation, \"rawResponse\")) {\n          data = await parseWithSchema(rawResponseSchema, result.data, \"rawResponseSchema\", result.meta);\n        }\n        let transformedResponse = await transformResponse(data, result.meta, finalQueryArg);\n        if (responseSchema && !shouldSkip(skipSchemaValidation, \"response\")) {\n          transformedResponse = await parseWithSchema(responseSchema, transformedResponse, \"responseSchema\", result.meta);\n        }\n        return {\n          ...result,\n          data: transformedResponse\n        };\n      }\n      if (isQuery && \"infiniteQueryOptions\" in endpointDefinition) {\n        const {\n          infiniteQueryOptions\n        } = endpointDefinition;\n        const {\n          maxPages = Infinity\n        } = infiniteQueryOptions;\n        let result;\n        const blankData = {\n          pages: [],\n          pageParams: []\n        };\n        const cachedData = selectors.selectQueryEntry(getState(), arg.queryCacheKey)?.data;\n        const isForcedQueryNeedingRefetch = (\n          // arg.forceRefetch\n          isForcedQuery(arg, getState()) && !arg.direction\n        );\n        const existingData = isForcedQueryNeedingRefetch || !cachedData ? blankData : cachedData;\n        if (\"direction\" in arg && arg.direction && existingData.pages.length) {\n          const previous = arg.direction === \"backward\";\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const param = pageParamFn(infiniteQueryOptions, existingData, arg.originalArgs);\n          result = await fetchPage(existingData, param, maxPages, previous);\n        } else {\n          const {\n            initialPageParam = infiniteQueryOptions.initialPageParam\n          } = arg;\n          const cachedPageParams = cachedData?.pageParams ?? [];\n          const firstPageParam = cachedPageParams[0] ?? initialPageParam;\n          const totalPages = cachedPageParams.length;\n          result = await fetchPage(existingData, firstPageParam, maxPages);\n          if (forceQueryFn) {\n            result = {\n              data: result.data.pages[0]\n            };\n          }\n          for (let i = 1; i < totalPages; i++) {\n            const param = getNextPageParam(infiniteQueryOptions, result.data, arg.originalArgs);\n            result = await fetchPage(result.data, param, maxPages);\n          }\n        }\n        finalQueryReturnValue = result;\n      } else {\n        finalQueryReturnValue = await executeRequest(arg.originalArgs);\n      }\n      if (metaSchema && !shouldSkip(skipSchemaValidation, \"meta\") && finalQueryReturnValue.meta) {\n        finalQueryReturnValue.meta = await parseWithSchema(metaSchema, finalQueryReturnValue.meta, \"metaSchema\", finalQueryReturnValue.meta);\n      }\n      return fulfillWithValue(finalQueryReturnValue.data, addShouldAutoBatch({\n        fulfilledTimeStamp: Date.now(),\n        baseQueryMeta: finalQueryReturnValue.meta\n      }));\n    } catch (error) {\n      let caughtError = error;\n      if (caughtError instanceof HandledError) {\n        let transformErrorResponse = getTransformCallbackForEndpoint(endpointDefinition, \"transformErrorResponse\");\n        const {\n          rawErrorResponseSchema,\n          errorResponseSchema\n        } = endpointDefinition;\n        let {\n          value,\n          meta\n        } = caughtError;\n        try {\n          if (rawErrorResponseSchema && !shouldSkip(skipSchemaValidation, \"rawErrorResponse\")) {\n            value = await parseWithSchema(rawErrorResponseSchema, value, \"rawErrorResponseSchema\", meta);\n          }\n          if (metaSchema && !shouldSkip(skipSchemaValidation, \"meta\")) {\n            meta = await parseWithSchema(metaSchema, meta, \"metaSchema\", meta);\n          }\n          let transformedErrorResponse = await transformErrorResponse(value, meta, arg.originalArgs);\n          if (errorResponseSchema && !shouldSkip(skipSchemaValidation, \"errorResponse\")) {\n            transformedErrorResponse = await parseWithSchema(errorResponseSchema, transformedErrorResponse, \"errorResponseSchema\", meta);\n          }\n          return rejectWithValue(transformedErrorResponse, addShouldAutoBatch({\n            baseQueryMeta: meta\n          }));\n        } catch (e) {\n          caughtError = e;\n        }\n      }\n      try {\n        if (caughtError instanceof NamedSchemaError) {\n          const info = {\n            endpoint: arg.endpointName,\n            arg: arg.originalArgs,\n            type: arg.type,\n            queryCacheKey: isQuery ? arg.queryCacheKey : void 0\n          };\n          endpointDefinition.onSchemaFailure?.(caughtError, info);\n          onSchemaFailure?.(caughtError, info);\n          const {\n            catchSchemaFailure = globalCatchSchemaFailure\n          } = endpointDefinition;\n          if (catchSchemaFailure) {\n            return rejectWithValue(catchSchemaFailure(caughtError, info), addShouldAutoBatch({\n              baseQueryMeta: caughtError._bqMeta\n            }));\n          }\n        }\n      } catch (e) {\n        caughtError = e;\n      }\n      if (typeof process !== \"undefined\" && process.env.NODE_ENV !== \"production\") {\n        console.error(`An unhandled error occurred processing a request for the endpoint \"${arg.endpointName}\".\nIn the case of an unhandled error, no tags will be \"provided\" or \"invalidated\".`, caughtError);\n      } else {\n        console.error(caughtError);\n      }\n      throw caughtError;\n    }\n  };\n  function isForcedQuery(arg, state) {\n    const requestState = selectors.selectQueryEntry(state, arg.queryCacheKey);\n    const baseFetchOnMountOrArgChange = selectors.selectConfig(state).refetchOnMountOrArgChange;\n    const fulfilledVal = requestState?.fulfilledTimeStamp;\n    const refetchVal = arg.forceRefetch ?? (arg.subscribe && baseFetchOnMountOrArgChange);\n    if (refetchVal) {\n      return refetchVal === true || (Number(/* @__PURE__ */ new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;\n    }\n    return false;\n  }\n  const createQueryThunk = () => {\n    const generatedQueryThunk = createAsyncThunk(`${reducerPath}/executeQuery`, executeEndpoint, {\n      getPendingMeta({\n        arg\n      }) {\n        const endpointDefinition = endpointDefinitions[arg.endpointName];\n        return addShouldAutoBatch({\n          startedTimeStamp: Date.now(),\n          ...isInfiniteQueryDefinition(endpointDefinition) ? {\n            direction: arg.direction\n          } : {}\n        });\n      },\n      condition(queryThunkArg, {\n        getState\n      }) {\n        const state = getState();\n        const requestState = selectors.selectQueryEntry(state, queryThunkArg.queryCacheKey);\n        const fulfilledVal = requestState?.fulfilledTimeStamp;\n        const currentArg = queryThunkArg.originalArgs;\n        const previousArg = requestState?.originalArgs;\n        const endpointDefinition = endpointDefinitions[queryThunkArg.endpointName];\n        const direction = queryThunkArg.direction;\n        if (isUpsertQuery(queryThunkArg)) {\n          return true;\n        }\n        if (requestState?.status === \"pending\") {\n          return false;\n        }\n        if (isForcedQuery(queryThunkArg, state)) {\n          return true;\n        }\n        if (isQueryDefinition(endpointDefinition) && endpointDefinition?.forceRefetch?.({\n          currentArg,\n          previousArg,\n          endpointState: requestState,\n          state\n        })) {\n          return true;\n        }\n        if (fulfilledVal && !direction) {\n          return false;\n        }\n        return true;\n      },\n      dispatchConditionRejection: true\n    });\n    return generatedQueryThunk;\n  };\n  const queryThunk = createQueryThunk();\n  const infiniteQueryThunk = createQueryThunk();\n  const mutationThunk = createAsyncThunk(`${reducerPath}/executeMutation`, executeEndpoint, {\n    getPendingMeta() {\n      return addShouldAutoBatch({\n        startedTimeStamp: Date.now()\n      });\n    }\n  });\n  const hasTheForce = (options) => \"force\" in options;\n  const hasMaxAge = (options) => \"ifOlderThan\" in options;\n  const prefetch = (endpointName, arg, options = {}) => (dispatch, getState) => {\n    const force = hasTheForce(options) && options.force;\n    const maxAge = hasMaxAge(options) && options.ifOlderThan;\n    const queryAction = (force2 = true) => {\n      const options2 = {\n        forceRefetch: force2,\n        subscribe: false\n      };\n      return api.endpoints[endpointName].initiate(arg, options2);\n    };\n    const latestStateValue = api.endpoints[endpointName].select(arg)(getState());\n    if (force) {\n      dispatch(queryAction());\n    } else if (maxAge) {\n      const lastFulfilledTs = latestStateValue?.fulfilledTimeStamp;\n      if (!lastFulfilledTs) {\n        dispatch(queryAction());\n        return;\n      }\n      const shouldRetrigger = (Number(/* @__PURE__ */ new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;\n      if (shouldRetrigger) {\n        dispatch(queryAction());\n      }\n    } else {\n      dispatch(queryAction(false));\n    }\n  };\n  function matchesEndpoint(endpointName) {\n    return (action) => action?.meta?.arg?.endpointName === endpointName;\n  }\n  function buildMatchThunkActions(thunk, endpointName) {\n    return {\n      matchPending: isAllOf(isPending(thunk), matchesEndpoint(endpointName)),\n      matchFulfilled: isAllOf(isFulfilled(thunk), matchesEndpoint(endpointName)),\n      matchRejected: isAllOf(isRejected(thunk), matchesEndpoint(endpointName))\n    };\n  }\n  return {\n    queryThunk,\n    mutationThunk,\n    infiniteQueryThunk,\n    prefetch,\n    updateQueryData,\n    upsertQueryData,\n    patchQueryData,\n    buildMatchThunkActions\n  };\n}\nfunction getNextPageParam(options, {\n  pages,\n  pageParams\n}, queryArg) {\n  const lastIndex = pages.length - 1;\n  return options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams, queryArg);\n}\nfunction getPreviousPageParam(options, {\n  pages,\n  pageParams\n}, queryArg) {\n  return options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams, queryArg);\n}\nfunction calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {\n  return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], isFulfilled(action) ? action.payload : void 0, isRejectedWithValue(action) ? action.payload : void 0, action.meta.arg.originalArgs, \"baseQueryMeta\" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);\n}\n\n// src/query/utils/getCurrent.ts\nfunction getCurrent(value) {\n  return isDraft(value) ? current(value) : value;\n}\n\n// src/query/core/buildSlice.ts\nfunction updateQuerySubstateIfExists(state, queryCacheKey, update) {\n  const substate = state[queryCacheKey];\n  if (substate) {\n    update(substate);\n  }\n}\nfunction getMutationCacheKey(id) {\n  return (\"arg\" in id ? id.arg.fixedCacheKey : id.fixedCacheKey) ?? id.requestId;\n}\nfunction updateMutationSubstateIfExists(state, id, update) {\n  const substate = state[getMutationCacheKey(id)];\n  if (substate) {\n    update(substate);\n  }\n}\nvar initialState = {};\nfunction buildSlice({\n  reducerPath,\n  queryThunk,\n  mutationThunk,\n  serializeQueryArgs,\n  context: {\n    endpointDefinitions: definitions,\n    apiUid,\n    extractRehydrationInfo,\n    hasRehydrationInfo\n  },\n  assertTagType,\n  config\n}) {\n  const resetApiState = createAction(`${reducerPath}/resetApiState`);\n  function writePendingCacheEntry(draft, arg, upserting, meta) {\n    draft[arg.queryCacheKey] ??= {\n      status: STATUS_UNINITIALIZED,\n      endpointName: arg.endpointName\n    };\n    updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {\n      substate.status = STATUS_PENDING;\n      substate.requestId = upserting && substate.requestId ? (\n        // for `upsertQuery` **updates**, keep the current `requestId`\n        substate.requestId\n      ) : (\n        // for normal queries or `upsertQuery` **inserts** always update the `requestId`\n        meta.requestId\n      );\n      if (arg.originalArgs !== void 0) {\n        substate.originalArgs = arg.originalArgs;\n      }\n      substate.startedTimeStamp = meta.startedTimeStamp;\n      const endpointDefinition = definitions[meta.arg.endpointName];\n      if (isInfiniteQueryDefinition(endpointDefinition) && \"direction\" in arg) {\n        ;\n        substate.direction = arg.direction;\n      }\n    });\n  }\n  function writeFulfilledCacheEntry(draft, meta, payload, upserting) {\n    updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, (substate) => {\n      if (substate.requestId !== meta.requestId && !upserting) return;\n      const {\n        merge\n      } = definitions[meta.arg.endpointName];\n      substate.status = STATUS_FULFILLED;\n      if (merge) {\n        if (substate.data !== void 0) {\n          const {\n            fulfilledTimeStamp,\n            arg,\n            baseQueryMeta,\n            requestId\n          } = meta;\n          let newData = createNextState(substate.data, (draftSubstateData) => {\n            return merge(draftSubstateData, payload, {\n              arg: arg.originalArgs,\n              baseQueryMeta,\n              fulfilledTimeStamp,\n              requestId\n            });\n          });\n          substate.data = newData;\n        } else {\n          substate.data = payload;\n        }\n      } else {\n        substate.data = definitions[meta.arg.endpointName].structuralSharing ?? true ? copyWithStructuralSharing(isDraft(substate.data) ? original(substate.data) : substate.data, payload) : payload;\n      }\n      delete substate.error;\n      substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n    });\n  }\n  const querySlice = createSlice({\n    name: `${reducerPath}/queries`,\n    initialState,\n    reducers: {\n      removeQueryResult: {\n        reducer(draft, {\n          payload: {\n            queryCacheKey\n          }\n        }) {\n          delete draft[queryCacheKey];\n        },\n        prepare: prepareAutoBatched()\n      },\n      cacheEntriesUpserted: {\n        reducer(draft, action) {\n          for (const entry of action.payload) {\n            const {\n              queryDescription: arg,\n              value\n            } = entry;\n            writePendingCacheEntry(draft, arg, true, {\n              arg,\n              requestId: action.meta.requestId,\n              startedTimeStamp: action.meta.timestamp\n            });\n            writeFulfilledCacheEntry(\n              draft,\n              {\n                arg,\n                requestId: action.meta.requestId,\n                fulfilledTimeStamp: action.meta.timestamp,\n                baseQueryMeta: {}\n              },\n              value,\n              // We know we're upserting here\n              true\n            );\n          }\n        },\n        prepare: (payload) => {\n          const queryDescriptions = payload.map((entry) => {\n            const {\n              endpointName,\n              arg,\n              value\n            } = entry;\n            const endpointDefinition = definitions[endpointName];\n            const queryDescription = {\n              type: ENDPOINT_QUERY,\n              endpointName,\n              originalArgs: entry.arg,\n              queryCacheKey: serializeQueryArgs({\n                queryArgs: arg,\n                endpointDefinition,\n                endpointName\n              })\n            };\n            return {\n              queryDescription,\n              value\n            };\n          });\n          const result = {\n            payload: queryDescriptions,\n            meta: {\n              [SHOULD_AUTOBATCH]: true,\n              requestId: nanoid(),\n              timestamp: Date.now()\n            }\n          };\n          return result;\n        }\n      },\n      queryResultPatched: {\n        reducer(draft, {\n          payload: {\n            queryCacheKey,\n            patches\n          }\n        }) {\n          updateQuerySubstateIfExists(draft, queryCacheKey, (substate) => {\n            substate.data = applyPatches(substate.data, patches.concat());\n          });\n        },\n        prepare: prepareAutoBatched()\n      }\n    },\n    extraReducers(builder) {\n      builder.addCase(queryThunk.pending, (draft, {\n        meta,\n        meta: {\n          arg\n        }\n      }) => {\n        const upserting = isUpsertQuery(arg);\n        writePendingCacheEntry(draft, arg, upserting, meta);\n      }).addCase(queryThunk.fulfilled, (draft, {\n        meta,\n        payload\n      }) => {\n        const upserting = isUpsertQuery(meta.arg);\n        writeFulfilledCacheEntry(draft, meta, payload, upserting);\n      }).addCase(queryThunk.rejected, (draft, {\n        meta: {\n          condition,\n          arg,\n          requestId\n        },\n        error,\n        payload\n      }) => {\n        updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {\n          if (condition) {\n          } else {\n            if (substate.requestId !== requestId) return;\n            substate.status = STATUS_REJECTED;\n            substate.error = payload ?? error;\n          }\n        });\n      }).addMatcher(hasRehydrationInfo, (draft, action) => {\n        const {\n          queries\n        } = extractRehydrationInfo(action);\n        for (const [key, entry] of Object.entries(queries)) {\n          if (\n            // do not rehydrate entries that were currently in flight.\n            entry?.status === STATUS_FULFILLED || entry?.status === STATUS_REJECTED\n          ) {\n            draft[key] = entry;\n          }\n        }\n      });\n    }\n  });\n  const mutationSlice = createSlice({\n    name: `${reducerPath}/mutations`,\n    initialState,\n    reducers: {\n      removeMutationResult: {\n        reducer(draft, {\n          payload\n        }) {\n          const cacheKey = getMutationCacheKey(payload);\n          if (cacheKey in draft) {\n            delete draft[cacheKey];\n          }\n        },\n        prepare: prepareAutoBatched()\n      }\n    },\n    extraReducers(builder) {\n      builder.addCase(mutationThunk.pending, (draft, {\n        meta,\n        meta: {\n          requestId,\n          arg,\n          startedTimeStamp\n        }\n      }) => {\n        if (!arg.track) return;\n        draft[getMutationCacheKey(meta)] = {\n          requestId,\n          status: STATUS_PENDING,\n          endpointName: arg.endpointName,\n          startedTimeStamp\n        };\n      }).addCase(mutationThunk.fulfilled, (draft, {\n        payload,\n        meta\n      }) => {\n        if (!meta.arg.track) return;\n        updateMutationSubstateIfExists(draft, meta, (substate) => {\n          if (substate.requestId !== meta.requestId) return;\n          substate.status = STATUS_FULFILLED;\n          substate.data = payload;\n          substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n        });\n      }).addCase(mutationThunk.rejected, (draft, {\n        payload,\n        error,\n        meta\n      }) => {\n        if (!meta.arg.track) return;\n        updateMutationSubstateIfExists(draft, meta, (substate) => {\n          if (substate.requestId !== meta.requestId) return;\n          substate.status = STATUS_REJECTED;\n          substate.error = payload ?? error;\n        });\n      }).addMatcher(hasRehydrationInfo, (draft, action) => {\n        const {\n          mutations\n        } = extractRehydrationInfo(action);\n        for (const [key, entry] of Object.entries(mutations)) {\n          if (\n            // do not rehydrate entries that were currently in flight.\n            (entry?.status === STATUS_FULFILLED || entry?.status === STATUS_REJECTED) && // only rehydrate endpoints that were persisted using a `fixedCacheKey`\n            key !== entry?.requestId\n          ) {\n            draft[key] = entry;\n          }\n        }\n      });\n    }\n  });\n  const initialInvalidationState = {\n    tags: {},\n    keys: {}\n  };\n  const invalidationSlice = createSlice({\n    name: `${reducerPath}/invalidation`,\n    initialState: initialInvalidationState,\n    reducers: {\n      updateProvidedBy: {\n        reducer(draft, action) {\n          for (const {\n            queryCacheKey,\n            providedTags\n          } of action.payload) {\n            removeCacheKeyFromTags(draft, queryCacheKey);\n            for (const {\n              type,\n              id\n            } of providedTags) {\n              const subscribedQueries = (draft.tags[type] ??= {})[id || \"__internal_without_id\"] ??= [];\n              const alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n              if (!alreadySubscribed) {\n                subscribedQueries.push(queryCacheKey);\n              }\n            }\n            draft.keys[queryCacheKey] = providedTags;\n          }\n        },\n        prepare: prepareAutoBatched()\n      }\n    },\n    extraReducers(builder) {\n      builder.addCase(querySlice.actions.removeQueryResult, (draft, {\n        payload: {\n          queryCacheKey\n        }\n      }) => {\n        removeCacheKeyFromTags(draft, queryCacheKey);\n      }).addMatcher(hasRehydrationInfo, (draft, action) => {\n        const {\n          provided\n        } = extractRehydrationInfo(action);\n        for (const [type, incomingTags] of Object.entries(provided.tags ?? {})) {\n          for (const [id, cacheKeys] of Object.entries(incomingTags)) {\n            const subscribedQueries = (draft.tags[type] ??= {})[id || \"__internal_without_id\"] ??= [];\n            for (const queryCacheKey of cacheKeys) {\n              const alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n              if (!alreadySubscribed) {\n                subscribedQueries.push(queryCacheKey);\n              }\n              draft.keys[queryCacheKey] = provided.keys[queryCacheKey];\n            }\n          }\n        }\n      }).addMatcher(isAnyOf(isFulfilled(queryThunk), isRejectedWithValue(queryThunk)), (draft, action) => {\n        writeProvidedTagsForQueries(draft, [action]);\n      }).addMatcher(querySlice.actions.cacheEntriesUpserted.match, (draft, action) => {\n        const mockActions = action.payload.map(({\n          queryDescription,\n          value\n        }) => {\n          return {\n            type: \"UNKNOWN\",\n            payload: value,\n            meta: {\n              requestStatus: \"fulfilled\",\n              requestId: \"UNKNOWN\",\n              arg: queryDescription\n            }\n          };\n        });\n        writeProvidedTagsForQueries(draft, mockActions);\n      });\n    }\n  });\n  function removeCacheKeyFromTags(draft, queryCacheKey) {\n    const existingTags = getCurrent(draft.keys[queryCacheKey] ?? []);\n    for (const tag of existingTags) {\n      const tagType = tag.type;\n      const tagId = tag.id ?? \"__internal_without_id\";\n      const tagSubscriptions = draft.tags[tagType]?.[tagId];\n      if (tagSubscriptions) {\n        draft.tags[tagType][tagId] = getCurrent(tagSubscriptions).filter((qc) => qc !== queryCacheKey);\n      }\n    }\n    delete draft.keys[queryCacheKey];\n  }\n  function writeProvidedTagsForQueries(draft, actions3) {\n    const providedByEntries = actions3.map((action) => {\n      const providedTags = calculateProvidedByThunk(action, \"providesTags\", definitions, assertTagType);\n      const {\n        queryCacheKey\n      } = action.meta.arg;\n      return {\n        queryCacheKey,\n        providedTags\n      };\n    });\n    invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy(providedByEntries));\n  }\n  const subscriptionSlice = createSlice({\n    name: `${reducerPath}/subscriptions`,\n    initialState,\n    reducers: {\n      updateSubscriptionOptions(d, a) {\n      },\n      unsubscribeQueryResult(d, a) {\n      },\n      internal_getRTKQSubscriptions() {\n      }\n    }\n  });\n  const internalSubscriptionsSlice = createSlice({\n    name: `${reducerPath}/internalSubscriptions`,\n    initialState,\n    reducers: {\n      subscriptionsUpdated: {\n        reducer(state, action) {\n          return applyPatches(state, action.payload);\n        },\n        prepare: prepareAutoBatched()\n      }\n    }\n  });\n  const configSlice = createSlice({\n    name: `${reducerPath}/config`,\n    initialState: {\n      online: isOnline(),\n      focused: isDocumentVisible(),\n      middlewareRegistered: false,\n      ...config\n    },\n    reducers: {\n      middlewareRegistered(state, {\n        payload\n      }) {\n        state.middlewareRegistered = state.middlewareRegistered === \"conflict\" || apiUid !== payload ? \"conflict\" : true;\n      }\n    },\n    extraReducers: (builder) => {\n      builder.addCase(onOnline, (state) => {\n        state.online = true;\n      }).addCase(onOffline, (state) => {\n        state.online = false;\n      }).addCase(onFocus, (state) => {\n        state.focused = true;\n      }).addCase(onFocusLost, (state) => {\n        state.focused = false;\n      }).addMatcher(hasRehydrationInfo, (draft) => ({\n        ...draft\n      }));\n    }\n  });\n  const combinedReducer = combineReducers({\n    queries: querySlice.reducer,\n    mutations: mutationSlice.reducer,\n    provided: invalidationSlice.reducer,\n    subscriptions: internalSubscriptionsSlice.reducer,\n    config: configSlice.reducer\n  });\n  const reducer = (state, action) => combinedReducer(resetApiState.match(action) ? void 0 : state, action);\n  const actions2 = {\n    ...configSlice.actions,\n    ...querySlice.actions,\n    ...subscriptionSlice.actions,\n    ...internalSubscriptionsSlice.actions,\n    ...mutationSlice.actions,\n    ...invalidationSlice.actions,\n    resetApiState\n  };\n  return {\n    reducer,\n    actions: actions2\n  };\n}\n\n// src/query/core/buildSelectors.ts\nvar skipToken = /* @__PURE__ */ Symbol.for(\"RTKQ/skipToken\");\nvar initialSubState = {\n  status: STATUS_UNINITIALIZED\n};\nvar defaultQuerySubState = /* @__PURE__ */ createNextState(initialSubState, () => {\n});\nvar defaultMutationSubState = /* @__PURE__ */ createNextState(initialSubState, () => {\n});\nfunction buildSelectors({\n  serializeQueryArgs,\n  reducerPath,\n  createSelector: createSelector2\n}) {\n  const selectSkippedQuery = (state) => defaultQuerySubState;\n  const selectSkippedMutation = (state) => defaultMutationSubState;\n  return {\n    buildQuerySelector,\n    buildInfiniteQuerySelector,\n    buildMutationSelector,\n    selectInvalidatedBy,\n    selectCachedArgsForQuery,\n    selectApiState,\n    selectQueries,\n    selectMutations,\n    selectQueryEntry,\n    selectConfig\n  };\n  function withRequestFlags(substate) {\n    return {\n      ...substate,\n      ...getRequestStatusFlags(substate.status)\n    };\n  }\n  function selectApiState(rootState) {\n    const state = rootState[reducerPath];\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!state) {\n        if (selectApiState.triggered) return state;\n        selectApiState.triggered = true;\n        console.error(`Error: No data found at \\`state.${reducerPath}\\`. Did you forget to add the reducer to the store?`);\n      }\n    }\n    return state;\n  }\n  function selectQueries(rootState) {\n    return selectApiState(rootState)?.queries;\n  }\n  function selectQueryEntry(rootState, cacheKey) {\n    return selectQueries(rootState)?.[cacheKey];\n  }\n  function selectMutations(rootState) {\n    return selectApiState(rootState)?.mutations;\n  }\n  function selectConfig(rootState) {\n    return selectApiState(rootState)?.config;\n  }\n  function buildAnyQuerySelector(endpointName, endpointDefinition, combiner) {\n    return (queryArgs) => {\n      if (queryArgs === skipToken) {\n        return createSelector2(selectSkippedQuery, combiner);\n      }\n      const serializedArgs = serializeQueryArgs({\n        queryArgs,\n        endpointDefinition,\n        endpointName\n      });\n      const selectQuerySubstate = (state) => selectQueryEntry(state, serializedArgs) ?? defaultQuerySubState;\n      return createSelector2(selectQuerySubstate, combiner);\n    };\n  }\n  function buildQuerySelector(endpointName, endpointDefinition) {\n    return buildAnyQuerySelector(endpointName, endpointDefinition, withRequestFlags);\n  }\n  function buildInfiniteQuerySelector(endpointName, endpointDefinition) {\n    const {\n      infiniteQueryOptions\n    } = endpointDefinition;\n    function withInfiniteQueryResultFlags(substate) {\n      const stateWithRequestFlags = {\n        ...substate,\n        ...getRequestStatusFlags(substate.status)\n      };\n      const {\n        isLoading,\n        isError,\n        direction\n      } = stateWithRequestFlags;\n      const isForward = direction === \"forward\";\n      const isBackward = direction === \"backward\";\n      return {\n        ...stateWithRequestFlags,\n        hasNextPage: getHasNextPage(infiniteQueryOptions, stateWithRequestFlags.data, stateWithRequestFlags.originalArgs),\n        hasPreviousPage: getHasPreviousPage(infiniteQueryOptions, stateWithRequestFlags.data, stateWithRequestFlags.originalArgs),\n        isFetchingNextPage: isLoading && isForward,\n        isFetchingPreviousPage: isLoading && isBackward,\n        isFetchNextPageError: isError && isForward,\n        isFetchPreviousPageError: isError && isBackward\n      };\n    }\n    return buildAnyQuerySelector(endpointName, endpointDefinition, withInfiniteQueryResultFlags);\n  }\n  function buildMutationSelector() {\n    return (id) => {\n      let mutationId;\n      if (typeof id === \"object\") {\n        mutationId = getMutationCacheKey(id) ?? skipToken;\n      } else {\n        mutationId = id;\n      }\n      const selectMutationSubstate = (state) => selectApiState(state)?.mutations?.[mutationId] ?? defaultMutationSubState;\n      const finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;\n      return createSelector2(finalSelectMutationSubstate, withRequestFlags);\n    };\n  }\n  function selectInvalidatedBy(state, tags) {\n    const apiState = state[reducerPath];\n    const toInvalidate = /* @__PURE__ */ new Set();\n    const finalTags = filterMap(tags, isNotNullish, expandTagDescription);\n    for (const tag of finalTags) {\n      const provided = apiState.provided.tags[tag.type];\n      if (!provided) {\n        continue;\n      }\n      let invalidateSubscriptions = (tag.id !== void 0 ? (\n        // id given: invalidate all queries that provide this type & id\n        provided[tag.id]\n      ) : (\n        // no id: invalidate all queries that provide this type\n        Object.values(provided).flat()\n      )) ?? [];\n      for (const invalidate of invalidateSubscriptions) {\n        toInvalidate.add(invalidate);\n      }\n    }\n    return Array.from(toInvalidate.values()).flatMap((queryCacheKey) => {\n      const querySubState = apiState.queries[queryCacheKey];\n      return querySubState ? {\n        queryCacheKey,\n        endpointName: querySubState.endpointName,\n        originalArgs: querySubState.originalArgs\n      } : [];\n    });\n  }\n  function selectCachedArgsForQuery(state, queryName) {\n    return filterMap(Object.values(selectQueries(state)), (entry) => entry?.endpointName === queryName && entry.status !== STATUS_UNINITIALIZED, (entry) => entry.originalArgs);\n  }\n  function getHasNextPage(options, data, queryArg) {\n    if (!data) return false;\n    return getNextPageParam(options, data, queryArg) != null;\n  }\n  function getHasPreviousPage(options, data, queryArg) {\n    if (!data || !options.getPreviousPageParam) return false;\n    return getPreviousPageParam(options, data, queryArg) != null;\n  }\n}\n\n// src/query/createApi.ts\nimport { formatProdErrorMessage as _formatProdErrorMessage2, formatProdErrorMessage as _formatProdErrorMessage22, formatProdErrorMessage as _formatProdErrorMessage3 } from \"@reduxjs/toolkit\";\n\n// src/query/defaultSerializeQueryArgs.ts\nvar cache = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;\nvar defaultSerializeQueryArgs = ({\n  endpointName,\n  queryArgs\n}) => {\n  let serialized = \"\";\n  const cached = cache?.get(queryArgs);\n  if (typeof cached === \"string\") {\n    serialized = cached;\n  } else {\n    const stringified = JSON.stringify(queryArgs, (key, value) => {\n      value = typeof value === \"bigint\" ? {\n        $bigint: value.toString()\n      } : value;\n      value = isPlainObject(value) ? Object.keys(value).sort().reduce((acc, key2) => {\n        acc[key2] = value[key2];\n        return acc;\n      }, {}) : value;\n      return value;\n    });\n    if (isPlainObject(queryArgs)) {\n      cache?.set(queryArgs, stringified);\n    }\n    serialized = stringified;\n  }\n  return `${endpointName}(${serialized})`;\n};\n\n// src/query/createApi.ts\nimport { weakMapMemoize } from \"reselect\";\nfunction buildCreateApi(...modules) {\n  return function baseCreateApi(options) {\n    const extractRehydrationInfo = weakMapMemoize((action) => options.extractRehydrationInfo?.(action, {\n      reducerPath: options.reducerPath ?? \"api\"\n    }));\n    const optionsWithDefaults = {\n      reducerPath: \"api\",\n      keepUnusedDataFor: 60,\n      refetchOnMountOrArgChange: false,\n      refetchOnFocus: false,\n      refetchOnReconnect: false,\n      invalidationBehavior: \"delayed\",\n      ...options,\n      extractRehydrationInfo,\n      serializeQueryArgs(queryArgsApi) {\n        let finalSerializeQueryArgs = defaultSerializeQueryArgs;\n        if (\"serializeQueryArgs\" in queryArgsApi.endpointDefinition) {\n          const endpointSQA = queryArgsApi.endpointDefinition.serializeQueryArgs;\n          finalSerializeQueryArgs = (queryArgsApi2) => {\n            const initialResult = endpointSQA(queryArgsApi2);\n            if (typeof initialResult === \"string\") {\n              return initialResult;\n            } else {\n              return defaultSerializeQueryArgs({\n                ...queryArgsApi2,\n                queryArgs: initialResult\n              });\n            }\n          };\n        } else if (options.serializeQueryArgs) {\n          finalSerializeQueryArgs = options.serializeQueryArgs;\n        }\n        return finalSerializeQueryArgs(queryArgsApi);\n      },\n      tagTypes: [...options.tagTypes || []]\n    };\n    const context = {\n      endpointDefinitions: {},\n      batch(fn) {\n        fn();\n      },\n      apiUid: nanoid(),\n      extractRehydrationInfo,\n      hasRehydrationInfo: weakMapMemoize((action) => extractRehydrationInfo(action) != null)\n    };\n    const api = {\n      injectEndpoints,\n      enhanceEndpoints({\n        addTagTypes,\n        endpoints\n      }) {\n        if (addTagTypes) {\n          for (const eT of addTagTypes) {\n            if (!optionsWithDefaults.tagTypes.includes(eT)) {\n              ;\n              optionsWithDefaults.tagTypes.push(eT);\n            }\n          }\n        }\n        if (endpoints) {\n          for (const [endpointName, partialDefinition] of Object.entries(endpoints)) {\n            if (typeof partialDefinition === \"function\") {\n              partialDefinition(getEndpointDefinition(context, endpointName));\n            } else {\n              Object.assign(getEndpointDefinition(context, endpointName) || {}, partialDefinition);\n            }\n          }\n        }\n        return api;\n      }\n    };\n    const initializedModules = modules.map((m) => m.init(api, optionsWithDefaults, context));\n    function injectEndpoints(inject) {\n      const evaluatedEndpoints = inject.endpoints({\n        query: (x) => ({\n          ...x,\n          type: ENDPOINT_QUERY\n        }),\n        mutation: (x) => ({\n          ...x,\n          type: ENDPOINT_MUTATION\n        }),\n        infiniteQuery: (x) => ({\n          ...x,\n          type: ENDPOINT_INFINITEQUERY\n        })\n      });\n      for (const [endpointName, definition] of Object.entries(evaluatedEndpoints)) {\n        if (inject.overrideExisting !== true && endpointName in context.endpointDefinitions) {\n          if (inject.overrideExisting === \"throw\") {\n            throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage2(39) : `called \\`injectEndpoints\\` to override already-existing endpointName ${endpointName} without specifying \\`overrideExisting: true\\``);\n          } else if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\n            console.error(`called \\`injectEndpoints\\` to override already-existing endpointName ${endpointName} without specifying \\`overrideExisting: true\\``);\n          }\n          continue;\n        }\n        if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\n          if (isInfiniteQueryDefinition(definition)) {\n            const {\n              infiniteQueryOptions\n            } = definition;\n            const {\n              maxPages,\n              getPreviousPageParam: getPreviousPageParam2\n            } = infiniteQueryOptions;\n            if (typeof maxPages === \"number\") {\n              if (maxPages < 1) {\n                throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage22(40) : `maxPages for endpoint '${endpointName}' must be a number greater than 0`);\n              }\n              if (typeof getPreviousPageParam2 !== \"function\") {\n                throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage3(41) : `getPreviousPageParam for endpoint '${endpointName}' must be a function if maxPages is used`);\n              }\n            }\n          }\n        }\n        context.endpointDefinitions[endpointName] = definition;\n        for (const m of initializedModules) {\n          m.injectEndpoint(endpointName, definition);\n        }\n      }\n      return api;\n    }\n    return api.injectEndpoints({\n      endpoints: options.endpoints\n    });\n  };\n}\n\n// src/query/fakeBaseQuery.ts\nimport { formatProdErrorMessage as _formatProdErrorMessage4 } from \"@reduxjs/toolkit\";\nvar _NEVER = /* @__PURE__ */ Symbol();\nfunction fakeBaseQuery() {\n  return function() {\n    throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage4(33) : \"When using `fakeBaseQuery`, all queries & mutations must use the `queryFn` definition syntax.\");\n  };\n}\n\n// src/query/tsHelpers.ts\nfunction assertCast(v) {\n}\nfunction safeAssign(target, ...args) {\n  return Object.assign(target, ...args);\n}\n\n// src/query/core/buildMiddleware/batchActions.ts\nvar buildBatchedActionsHandler = ({\n  api,\n  queryThunk,\n  internalState,\n  mwApi\n}) => {\n  const subscriptionsPrefix = `${api.reducerPath}/subscriptions`;\n  let previousSubscriptions = null;\n  let updateSyncTimer = null;\n  const {\n    updateSubscriptionOptions,\n    unsubscribeQueryResult\n  } = api.internalActions;\n  const actuallyMutateSubscriptions = (currentSubscriptions, action) => {\n    if (updateSubscriptionOptions.match(action)) {\n      const {\n        queryCacheKey,\n        requestId,\n        options\n      } = action.payload;\n      const sub = currentSubscriptions.get(queryCacheKey);\n      if (sub?.has(requestId)) {\n        sub.set(requestId, options);\n      }\n      return true;\n    }\n    if (unsubscribeQueryResult.match(action)) {\n      const {\n        queryCacheKey,\n        requestId\n      } = action.payload;\n      const sub = currentSubscriptions.get(queryCacheKey);\n      if (sub) {\n        sub.delete(requestId);\n      }\n      return true;\n    }\n    if (api.internalActions.removeQueryResult.match(action)) {\n      currentSubscriptions.delete(action.payload.queryCacheKey);\n      return true;\n    }\n    if (queryThunk.pending.match(action)) {\n      const {\n        meta: {\n          arg,\n          requestId\n        }\n      } = action;\n      const substate = getOrInsertComputed(currentSubscriptions, arg.queryCacheKey, createNewMap);\n      if (arg.subscribe) {\n        substate.set(requestId, arg.subscriptionOptions ?? substate.get(requestId) ?? {});\n      }\n      return true;\n    }\n    let mutated = false;\n    if (queryThunk.rejected.match(action)) {\n      const {\n        meta: {\n          condition,\n          arg,\n          requestId\n        }\n      } = action;\n      if (condition && arg.subscribe) {\n        const substate = getOrInsertComputed(currentSubscriptions, arg.queryCacheKey, createNewMap);\n        substate.set(requestId, arg.subscriptionOptions ?? substate.get(requestId) ?? {});\n        mutated = true;\n      }\n    }\n    return mutated;\n  };\n  const getSubscriptions = () => internalState.currentSubscriptions;\n  const getSubscriptionCount = (queryCacheKey) => {\n    const subscriptions = getSubscriptions();\n    const subscriptionsForQueryArg = subscriptions.get(queryCacheKey);\n    return subscriptionsForQueryArg?.size ?? 0;\n  };\n  const isRequestSubscribed = (queryCacheKey, requestId) => {\n    const subscriptions = getSubscriptions();\n    return !!subscriptions?.get(queryCacheKey)?.get(requestId);\n  };\n  const subscriptionSelectors = {\n    getSubscriptions,\n    getSubscriptionCount,\n    isRequestSubscribed\n  };\n  function serializeSubscriptions(currentSubscriptions) {\n    return JSON.parse(JSON.stringify(Object.fromEntries([...currentSubscriptions].map(([k, v]) => [k, Object.fromEntries(v)]))));\n  }\n  return (action, mwApi2) => {\n    if (!previousSubscriptions) {\n      previousSubscriptions = serializeSubscriptions(internalState.currentSubscriptions);\n    }\n    if (api.util.resetApiState.match(action)) {\n      previousSubscriptions = {};\n      internalState.currentSubscriptions.clear();\n      updateSyncTimer = null;\n      return [true, false];\n    }\n    if (api.internalActions.internal_getRTKQSubscriptions.match(action)) {\n      return [false, subscriptionSelectors];\n    }\n    const didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);\n    let actionShouldContinue = true;\n    if (process.env.NODE_ENV === \"test\" && typeof action.type === \"string\" && action.type === `${api.reducerPath}/getPolling`) {\n      return [false, internalState.currentPolls];\n    }\n    if (didMutate) {\n      if (!updateSyncTimer) {\n        updateSyncTimer = setTimeout(() => {\n          const newSubscriptions = serializeSubscriptions(internalState.currentSubscriptions);\n          const [, patches] = produceWithPatches(previousSubscriptions, () => newSubscriptions);\n          mwApi2.next(api.internalActions.subscriptionsUpdated(patches));\n          previousSubscriptions = newSubscriptions;\n          updateSyncTimer = null;\n        }, 500);\n      }\n      const isSubscriptionSliceAction = typeof action.type == \"string\" && !!action.type.startsWith(subscriptionsPrefix);\n      const isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;\n      actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;\n    }\n    return [actionShouldContinue, false];\n  };\n};\n\n// src/query/core/buildMiddleware/cacheCollection.ts\nvar THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;\nvar buildCacheCollectionHandler = ({\n  reducerPath,\n  api,\n  queryThunk,\n  context,\n  internalState,\n  selectors: {\n    selectQueryEntry,\n    selectConfig\n  },\n  getRunningQueryThunk,\n  mwApi\n}) => {\n  const {\n    removeQueryResult,\n    unsubscribeQueryResult,\n    cacheEntriesUpserted\n  } = api.internalActions;\n  const canTriggerUnsubscribe = isAnyOf(unsubscribeQueryResult.match, queryThunk.fulfilled, queryThunk.rejected, cacheEntriesUpserted.match);\n  function anySubscriptionsRemainingForKey(queryCacheKey) {\n    const subscriptions = internalState.currentSubscriptions.get(queryCacheKey);\n    if (!subscriptions) {\n      return false;\n    }\n    const hasSubscriptions = subscriptions.size > 0;\n    return hasSubscriptions;\n  }\n  const currentRemovalTimeouts = {};\n  function abortAllPromises(promiseMap) {\n    for (const promise of promiseMap.values()) {\n      promise?.abort?.();\n    }\n  }\n  const handler = (action, mwApi2) => {\n    const state = mwApi2.getState();\n    const config = selectConfig(state);\n    if (canTriggerUnsubscribe(action)) {\n      let queryCacheKeys;\n      if (cacheEntriesUpserted.match(action)) {\n        queryCacheKeys = action.payload.map((entry) => entry.queryDescription.queryCacheKey);\n      } else {\n        const {\n          queryCacheKey\n        } = unsubscribeQueryResult.match(action) ? action.payload : action.meta.arg;\n        queryCacheKeys = [queryCacheKey];\n      }\n      handleUnsubscribeMany(queryCacheKeys, mwApi2, config);\n    }\n    if (api.util.resetApiState.match(action)) {\n      for (const [key, timeout] of Object.entries(currentRemovalTimeouts)) {\n        if (timeout) clearTimeout(timeout);\n        delete currentRemovalTimeouts[key];\n      }\n      abortAllPromises(internalState.runningQueries);\n      abortAllPromises(internalState.runningMutations);\n    }\n    if (context.hasRehydrationInfo(action)) {\n      const {\n        queries\n      } = context.extractRehydrationInfo(action);\n      handleUnsubscribeMany(Object.keys(queries), mwApi2, config);\n    }\n  };\n  function handleUnsubscribeMany(cacheKeys, api2, config) {\n    const state = api2.getState();\n    for (const queryCacheKey of cacheKeys) {\n      const entry = selectQueryEntry(state, queryCacheKey);\n      if (entry?.endpointName) {\n        handleUnsubscribe(queryCacheKey, entry.endpointName, api2, config);\n      }\n    }\n  }\n  function handleUnsubscribe(queryCacheKey, endpointName, api2, config) {\n    const endpointDefinition = getEndpointDefinition(context, endpointName);\n    const keepUnusedDataFor = endpointDefinition?.keepUnusedDataFor ?? config.keepUnusedDataFor;\n    if (keepUnusedDataFor === Infinity) {\n      return;\n    }\n    const finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));\n    if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n      const currentTimeout = currentRemovalTimeouts[queryCacheKey];\n      if (currentTimeout) {\n        clearTimeout(currentTimeout);\n      }\n      currentRemovalTimeouts[queryCacheKey] = setTimeout(() => {\n        if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n          const entry = selectQueryEntry(api2.getState(), queryCacheKey);\n          if (entry?.endpointName) {\n            const runningQuery = api2.dispatch(getRunningQueryThunk(entry.endpointName, entry.originalArgs));\n            runningQuery?.abort();\n          }\n          api2.dispatch(removeQueryResult({\n            queryCacheKey\n          }));\n        }\n        delete currentRemovalTimeouts[queryCacheKey];\n      }, finalKeepUnusedDataFor * 1e3);\n    }\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/cacheLifecycle.ts\nvar neverResolvedError = new Error(\"Promise never resolved before cacheEntryRemoved.\");\nvar buildCacheLifecycleHandler = ({\n  api,\n  reducerPath,\n  context,\n  queryThunk,\n  mutationThunk,\n  internalState,\n  selectors: {\n    selectQueryEntry,\n    selectApiState\n  }\n}) => {\n  const isQueryThunk = isAsyncThunkAction(queryThunk);\n  const isMutationThunk = isAsyncThunkAction(mutationThunk);\n  const isFulfilledThunk = isFulfilled(queryThunk, mutationThunk);\n  const lifecycleMap = {};\n  const {\n    removeQueryResult,\n    removeMutationResult,\n    cacheEntriesUpserted\n  } = api.internalActions;\n  function resolveLifecycleEntry(cacheKey, data, meta) {\n    const lifecycle = lifecycleMap[cacheKey];\n    if (lifecycle?.valueResolved) {\n      lifecycle.valueResolved({\n        data,\n        meta\n      });\n      delete lifecycle.valueResolved;\n    }\n  }\n  function removeLifecycleEntry(cacheKey) {\n    const lifecycle = lifecycleMap[cacheKey];\n    if (lifecycle) {\n      delete lifecycleMap[cacheKey];\n      lifecycle.cacheEntryRemoved();\n    }\n  }\n  function getActionMetaFields(action) {\n    const {\n      arg,\n      requestId\n    } = action.meta;\n    const {\n      endpointName,\n      originalArgs\n    } = arg;\n    return [endpointName, originalArgs, requestId];\n  }\n  const handler = (action, mwApi, stateBefore) => {\n    const cacheKey = getCacheKey(action);\n    function checkForNewCacheKey(endpointName, cacheKey2, requestId, originalArgs) {\n      const oldEntry = selectQueryEntry(stateBefore, cacheKey2);\n      const newEntry = selectQueryEntry(mwApi.getState(), cacheKey2);\n      if (!oldEntry && newEntry) {\n        handleNewKey(endpointName, originalArgs, cacheKey2, mwApi, requestId);\n      }\n    }\n    if (queryThunk.pending.match(action)) {\n      const [endpointName, originalArgs, requestId] = getActionMetaFields(action);\n      checkForNewCacheKey(endpointName, cacheKey, requestId, originalArgs);\n    } else if (cacheEntriesUpserted.match(action)) {\n      for (const {\n        queryDescription,\n        value\n      } of action.payload) {\n        const {\n          endpointName,\n          originalArgs,\n          queryCacheKey\n        } = queryDescription;\n        checkForNewCacheKey(endpointName, queryCacheKey, action.meta.requestId, originalArgs);\n        resolveLifecycleEntry(queryCacheKey, value, {});\n      }\n    } else if (mutationThunk.pending.match(action)) {\n      const state = mwApi.getState()[reducerPath].mutations[cacheKey];\n      if (state) {\n        const [endpointName, originalArgs, requestId] = getActionMetaFields(action);\n        handleNewKey(endpointName, originalArgs, cacheKey, mwApi, requestId);\n      }\n    } else if (isFulfilledThunk(action)) {\n      resolveLifecycleEntry(cacheKey, action.payload, action.meta.baseQueryMeta);\n    } else if (removeQueryResult.match(action) || removeMutationResult.match(action)) {\n      removeLifecycleEntry(cacheKey);\n    } else if (api.util.resetApiState.match(action)) {\n      for (const cacheKey2 of Object.keys(lifecycleMap)) {\n        removeLifecycleEntry(cacheKey2);\n      }\n    }\n  };\n  function getCacheKey(action) {\n    if (isQueryThunk(action)) return action.meta.arg.queryCacheKey;\n    if (isMutationThunk(action)) {\n      return action.meta.arg.fixedCacheKey ?? action.meta.requestId;\n    }\n    if (removeQueryResult.match(action)) return action.payload.queryCacheKey;\n    if (removeMutationResult.match(action)) return getMutationCacheKey(action.payload);\n    return \"\";\n  }\n  function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {\n    const endpointDefinition = getEndpointDefinition(context, endpointName);\n    const onCacheEntryAdded = endpointDefinition?.onCacheEntryAdded;\n    if (!onCacheEntryAdded) return;\n    const lifecycle = {};\n    const cacheEntryRemoved = new Promise((resolve) => {\n      lifecycle.cacheEntryRemoved = resolve;\n    });\n    const cacheDataLoaded = Promise.race([new Promise((resolve) => {\n      lifecycle.valueResolved = resolve;\n    }), cacheEntryRemoved.then(() => {\n      throw neverResolvedError;\n    })]);\n    cacheDataLoaded.catch(() => {\n    });\n    lifecycleMap[queryCacheKey] = lifecycle;\n    const selector = api.endpoints[endpointName].select(isAnyQueryDefinition(endpointDefinition) ? originalArgs : queryCacheKey);\n    const extra = mwApi.dispatch((_, __, extra2) => extra2);\n    const lifecycleApi = {\n      ...mwApi,\n      getCacheEntry: () => selector(mwApi.getState()),\n      requestId,\n      extra,\n      updateCachedData: isAnyQueryDefinition(endpointDefinition) ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,\n      cacheDataLoaded,\n      cacheEntryRemoved\n    };\n    const runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);\n    Promise.resolve(runningHandler).catch((e) => {\n      if (e === neverResolvedError) return;\n      throw e;\n    });\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/devMiddleware.ts\nvar buildDevCheckHandler = ({\n  api,\n  context: {\n    apiUid\n  },\n  reducerPath\n}) => {\n  return (action, mwApi) => {\n    if (api.util.resetApiState.match(action)) {\n      mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n    }\n    if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\n      if (api.internalActions.middlewareRegistered.match(action) && action.payload === apiUid && mwApi.getState()[reducerPath]?.config?.middlewareRegistered === \"conflict\") {\n        console.warn(`There is a mismatch between slice and middleware for the reducerPath \"${reducerPath}\".\nYou can only have one api per reducer path, this will lead to crashes in various situations!${reducerPath === \"api\" ? `\nIf you have multiple apis, you *have* to specify the reducerPath option when using createApi!` : \"\"}`);\n      }\n    }\n  };\n};\n\n// src/query/core/buildMiddleware/invalidationByTags.ts\nvar buildInvalidationByTagsHandler = ({\n  reducerPath,\n  context,\n  context: {\n    endpointDefinitions\n  },\n  mutationThunk,\n  queryThunk,\n  api,\n  assertTagType,\n  refetchQuery,\n  internalState\n}) => {\n  const {\n    removeQueryResult\n  } = api.internalActions;\n  const isThunkActionWithTags = isAnyOf(isFulfilled(mutationThunk), isRejectedWithValue(mutationThunk));\n  const isQueryEnd = isAnyOf(isFulfilled(queryThunk, mutationThunk), isRejected(queryThunk, mutationThunk));\n  let pendingTagInvalidations = [];\n  let pendingRequestCount = 0;\n  const handler = (action, mwApi) => {\n    if (queryThunk.pending.match(action) || mutationThunk.pending.match(action)) {\n      pendingRequestCount++;\n    }\n    if (isQueryEnd(action)) {\n      pendingRequestCount = Math.max(0, pendingRequestCount - 1);\n    }\n    if (isThunkActionWithTags(action)) {\n      invalidateTags(calculateProvidedByThunk(action, \"invalidatesTags\", endpointDefinitions, assertTagType), mwApi);\n    } else if (isQueryEnd(action)) {\n      invalidateTags([], mwApi);\n    } else if (api.util.invalidateTags.match(action)) {\n      invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);\n    }\n  };\n  function hasPendingRequests() {\n    return pendingRequestCount > 0;\n  }\n  function invalidateTags(newTags, mwApi) {\n    const rootState = mwApi.getState();\n    const state = rootState[reducerPath];\n    pendingTagInvalidations.push(...newTags);\n    if (state.config.invalidationBehavior === \"delayed\" && hasPendingRequests()) {\n      return;\n    }\n    const tags = pendingTagInvalidations;\n    pendingTagInvalidations = [];\n    if (tags.length === 0) return;\n    const toInvalidate = api.util.selectInvalidatedBy(rootState, tags);\n    context.batch(() => {\n      const valuesArray = Array.from(toInvalidate.values());\n      for (const {\n        queryCacheKey\n      } of valuesArray) {\n        const querySubState = state.queries[queryCacheKey];\n        const subscriptionSubState = getOrInsertComputed(internalState.currentSubscriptions, queryCacheKey, createNewMap);\n        if (querySubState) {\n          if (subscriptionSubState.size === 0) {\n            mwApi.dispatch(removeQueryResult({\n              queryCacheKey\n            }));\n          } else if (querySubState.status !== STATUS_UNINITIALIZED) {\n            mwApi.dispatch(refetchQuery(querySubState));\n          }\n        }\n      }\n    });\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/polling.ts\nvar buildPollingHandler = ({\n  reducerPath,\n  queryThunk,\n  api,\n  refetchQuery,\n  internalState\n}) => {\n  const {\n    currentPolls,\n    currentSubscriptions\n  } = internalState;\n  const pendingPollingUpdates = /* @__PURE__ */ new Set();\n  let pollingUpdateTimer = null;\n  const handler = (action, mwApi) => {\n    if (api.internalActions.updateSubscriptionOptions.match(action) || api.internalActions.unsubscribeQueryResult.match(action)) {\n      schedulePollingUpdate(action.payload.queryCacheKey, mwApi);\n    }\n    if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {\n      schedulePollingUpdate(action.meta.arg.queryCacheKey, mwApi);\n    }\n    if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {\n      startNextPoll(action.meta.arg, mwApi);\n    }\n    if (api.util.resetApiState.match(action)) {\n      clearPolls();\n      if (pollingUpdateTimer) {\n        clearTimeout(pollingUpdateTimer);\n        pollingUpdateTimer = null;\n      }\n      pendingPollingUpdates.clear();\n    }\n  };\n  function schedulePollingUpdate(queryCacheKey, api2) {\n    pendingPollingUpdates.add(queryCacheKey);\n    if (!pollingUpdateTimer) {\n      pollingUpdateTimer = setTimeout(() => {\n        for (const key of pendingPollingUpdates) {\n          updatePollingInterval({\n            queryCacheKey: key\n          }, api2);\n        }\n        pendingPollingUpdates.clear();\n        pollingUpdateTimer = null;\n      }, 0);\n    }\n  }\n  function startNextPoll({\n    queryCacheKey\n  }, api2) {\n    const state = api2.getState()[reducerPath];\n    const querySubState = state.queries[queryCacheKey];\n    const subscriptions = currentSubscriptions.get(queryCacheKey);\n    if (!querySubState || querySubState.status === STATUS_UNINITIALIZED) return;\n    const {\n      lowestPollingInterval,\n      skipPollingIfUnfocused\n    } = findLowestPollingInterval(subscriptions);\n    if (!Number.isFinite(lowestPollingInterval)) return;\n    const currentPoll = currentPolls.get(queryCacheKey);\n    if (currentPoll?.timeout) {\n      clearTimeout(currentPoll.timeout);\n      currentPoll.timeout = void 0;\n    }\n    const nextPollTimestamp = Date.now() + lowestPollingInterval;\n    currentPolls.set(queryCacheKey, {\n      nextPollTimestamp,\n      pollingInterval: lowestPollingInterval,\n      timeout: setTimeout(() => {\n        if (state.config.focused || !skipPollingIfUnfocused) {\n          api2.dispatch(refetchQuery(querySubState));\n        }\n        startNextPoll({\n          queryCacheKey\n        }, api2);\n      }, lowestPollingInterval)\n    });\n  }\n  function updatePollingInterval({\n    queryCacheKey\n  }, api2) {\n    const state = api2.getState()[reducerPath];\n    const querySubState = state.queries[queryCacheKey];\n    const subscriptions = currentSubscriptions.get(queryCacheKey);\n    if (!querySubState || querySubState.status === STATUS_UNINITIALIZED) {\n      return;\n    }\n    const {\n      lowestPollingInterval\n    } = findLowestPollingInterval(subscriptions);\n    if (process.env.NODE_ENV === \"test\") {\n      const updateCounters = currentPolls.pollUpdateCounters ??= {};\n      updateCounters[queryCacheKey] ??= 0;\n      updateCounters[queryCacheKey]++;\n    }\n    if (!Number.isFinite(lowestPollingInterval)) {\n      cleanupPollForKey(queryCacheKey);\n      return;\n    }\n    const currentPoll = currentPolls.get(queryCacheKey);\n    const nextPollTimestamp = Date.now() + lowestPollingInterval;\n    if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {\n      startNextPoll({\n        queryCacheKey\n      }, api2);\n    }\n  }\n  function cleanupPollForKey(key) {\n    const existingPoll = currentPolls.get(key);\n    if (existingPoll?.timeout) {\n      clearTimeout(existingPoll.timeout);\n    }\n    currentPolls.delete(key);\n  }\n  function clearPolls() {\n    for (const key of currentPolls.keys()) {\n      cleanupPollForKey(key);\n    }\n  }\n  function findLowestPollingInterval(subscribers = /* @__PURE__ */ new Map()) {\n    let skipPollingIfUnfocused = false;\n    let lowestPollingInterval = Number.POSITIVE_INFINITY;\n    for (const entry of subscribers.values()) {\n      if (!!entry.pollingInterval) {\n        lowestPollingInterval = Math.min(entry.pollingInterval, lowestPollingInterval);\n        skipPollingIfUnfocused = entry.skipPollingIfUnfocused || skipPollingIfUnfocused;\n      }\n    }\n    return {\n      lowestPollingInterval,\n      skipPollingIfUnfocused\n    };\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/queryLifecycle.ts\nvar buildQueryLifecycleHandler = ({\n  api,\n  context,\n  queryThunk,\n  mutationThunk\n}) => {\n  const isPendingThunk = isPending(queryThunk, mutationThunk);\n  const isRejectedThunk = isRejected(queryThunk, mutationThunk);\n  const isFullfilledThunk = isFulfilled(queryThunk, mutationThunk);\n  const lifecycleMap = {};\n  const handler = (action, mwApi) => {\n    if (isPendingThunk(action)) {\n      const {\n        requestId,\n        arg: {\n          endpointName,\n          originalArgs\n        }\n      } = action.meta;\n      const endpointDefinition = getEndpointDefinition(context, endpointName);\n      const onQueryStarted = endpointDefinition?.onQueryStarted;\n      if (onQueryStarted) {\n        const lifecycle = {};\n        const queryFulfilled = new Promise((resolve, reject) => {\n          lifecycle.resolve = resolve;\n          lifecycle.reject = reject;\n        });\n        queryFulfilled.catch(() => {\n        });\n        lifecycleMap[requestId] = lifecycle;\n        const selector = api.endpoints[endpointName].select(isAnyQueryDefinition(endpointDefinition) ? originalArgs : requestId);\n        const extra = mwApi.dispatch((_, __, extra2) => extra2);\n        const lifecycleApi = {\n          ...mwApi,\n          getCacheEntry: () => selector(mwApi.getState()),\n          requestId,\n          extra,\n          updateCachedData: isAnyQueryDefinition(endpointDefinition) ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,\n          queryFulfilled\n        };\n        onQueryStarted(originalArgs, lifecycleApi);\n      }\n    } else if (isFullfilledThunk(action)) {\n      const {\n        requestId,\n        baseQueryMeta\n      } = action.meta;\n      lifecycleMap[requestId]?.resolve({\n        data: action.payload,\n        meta: baseQueryMeta\n      });\n      delete lifecycleMap[requestId];\n    } else if (isRejectedThunk(action)) {\n      const {\n        requestId,\n        rejectedWithValue,\n        baseQueryMeta\n      } = action.meta;\n      lifecycleMap[requestId]?.reject({\n        error: action.payload ?? action.error,\n        isUnhandledError: !rejectedWithValue,\n        meta: baseQueryMeta\n      });\n      delete lifecycleMap[requestId];\n    }\n  };\n  return handler;\n};\n\n// src/query/core/buildMiddleware/windowEventHandling.ts\nvar buildWindowEventHandler = ({\n  reducerPath,\n  context,\n  api,\n  refetchQuery,\n  internalState\n}) => {\n  const {\n    removeQueryResult\n  } = api.internalActions;\n  const handler = (action, mwApi) => {\n    if (onFocus.match(action)) {\n      refetchValidQueries(mwApi, \"refetchOnFocus\");\n    }\n    if (onOnline.match(action)) {\n      refetchValidQueries(mwApi, \"refetchOnReconnect\");\n    }\n  };\n  function refetchValidQueries(api2, type) {\n    const state = api2.getState()[reducerPath];\n    const queries = state.queries;\n    const subscriptions = internalState.currentSubscriptions;\n    context.batch(() => {\n      for (const queryCacheKey of subscriptions.keys()) {\n        const querySubState = queries[queryCacheKey];\n        const subscriptionSubState = subscriptions.get(queryCacheKey);\n        if (!subscriptionSubState || !querySubState) continue;\n        const values = [...subscriptionSubState.values()];\n        const shouldRefetch = values.some((sub) => sub[type] === true) || values.every((sub) => sub[type] === void 0) && state.config[type];\n        if (shouldRefetch) {\n          if (subscriptionSubState.size === 0) {\n            api2.dispatch(removeQueryResult({\n              queryCacheKey\n            }));\n          } else if (querySubState.status !== STATUS_UNINITIALIZED) {\n            api2.dispatch(refetchQuery(querySubState));\n          }\n        }\n      }\n    });\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/index.ts\nfunction buildMiddleware(input) {\n  const {\n    reducerPath,\n    queryThunk,\n    api,\n    context,\n    getInternalState\n  } = input;\n  const {\n    apiUid\n  } = context;\n  const actions2 = {\n    invalidateTags: createAction(`${reducerPath}/invalidateTags`)\n  };\n  const isThisApiSliceAction = (action) => action.type.startsWith(`${reducerPath}/`);\n  const handlerBuilders = [buildDevCheckHandler, buildCacheCollectionHandler, buildInvalidationByTagsHandler, buildPollingHandler, buildCacheLifecycleHandler, buildQueryLifecycleHandler];\n  const middleware = (mwApi) => {\n    let initialized2 = false;\n    const internalState = getInternalState(mwApi.dispatch);\n    const builderArgs = {\n      ...input,\n      internalState,\n      refetchQuery,\n      isThisApiSliceAction,\n      mwApi\n    };\n    const handlers = handlerBuilders.map((build) => build(builderArgs));\n    const batchedActionsHandler = buildBatchedActionsHandler(builderArgs);\n    const windowEventsHandler = buildWindowEventHandler(builderArgs);\n    return (next) => {\n      return (action) => {\n        if (!isAction(action)) {\n          return next(action);\n        }\n        if (!initialized2) {\n          initialized2 = true;\n          mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n        }\n        const mwApiWithNext = {\n          ...mwApi,\n          next\n        };\n        const stateBefore = mwApi.getState();\n        const [actionShouldContinue, internalProbeResult] = batchedActionsHandler(action, mwApiWithNext, stateBefore);\n        let res;\n        if (actionShouldContinue) {\n          res = next(action);\n        } else {\n          res = internalProbeResult;\n        }\n        if (!!mwApi.getState()[reducerPath]) {\n          windowEventsHandler(action, mwApiWithNext, stateBefore);\n          if (isThisApiSliceAction(action) || context.hasRehydrationInfo(action)) {\n            for (const handler of handlers) {\n              handler(action, mwApiWithNext, stateBefore);\n            }\n          }\n        }\n        return res;\n      };\n    };\n  };\n  return {\n    middleware,\n    actions: actions2\n  };\n  function refetchQuery(querySubState) {\n    return input.api.endpoints[querySubState.endpointName].initiate(querySubState.originalArgs, {\n      subscribe: false,\n      forceRefetch: true\n    });\n  }\n}\n\n// src/query/core/module.ts\nvar coreModuleName = /* @__PURE__ */ Symbol();\nvar coreModule = ({\n  createSelector: createSelector2 = createSelector\n} = {}) => ({\n  name: coreModuleName,\n  init(api, {\n    baseQuery,\n    tagTypes,\n    reducerPath,\n    serializeQueryArgs,\n    keepUnusedDataFor,\n    refetchOnMountOrArgChange,\n    refetchOnFocus,\n    refetchOnReconnect,\n    invalidationBehavior,\n    onSchemaFailure,\n    catchSchemaFailure,\n    skipSchemaValidation\n  }, context) {\n    enablePatches();\n    assertCast(serializeQueryArgs);\n    const assertTagType = (tag) => {\n      if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\n        if (!tagTypes.includes(tag.type)) {\n          console.error(`Tag type '${tag.type}' was used, but not specified in \\`tagTypes\\`!`);\n        }\n      }\n      return tag;\n    };\n    Object.assign(api, {\n      reducerPath,\n      endpoints: {},\n      internalActions: {\n        onOnline,\n        onOffline,\n        onFocus,\n        onFocusLost\n      },\n      util: {}\n    });\n    const selectors = buildSelectors({\n      serializeQueryArgs,\n      reducerPath,\n      createSelector: createSelector2\n    });\n    const {\n      selectInvalidatedBy,\n      selectCachedArgsForQuery,\n      buildQuerySelector,\n      buildInfiniteQuerySelector,\n      buildMutationSelector\n    } = selectors;\n    safeAssign(api.util, {\n      selectInvalidatedBy,\n      selectCachedArgsForQuery\n    });\n    const {\n      queryThunk,\n      infiniteQueryThunk,\n      mutationThunk,\n      patchQueryData,\n      updateQueryData,\n      upsertQueryData,\n      prefetch,\n      buildMatchThunkActions\n    } = buildThunks({\n      baseQuery,\n      reducerPath,\n      context,\n      api,\n      serializeQueryArgs,\n      assertTagType,\n      selectors,\n      onSchemaFailure,\n      catchSchemaFailure,\n      skipSchemaValidation\n    });\n    const {\n      reducer,\n      actions: sliceActions\n    } = buildSlice({\n      context,\n      queryThunk,\n      infiniteQueryThunk,\n      mutationThunk,\n      serializeQueryArgs,\n      reducerPath,\n      assertTagType,\n      config: {\n        refetchOnFocus,\n        refetchOnReconnect,\n        refetchOnMountOrArgChange,\n        keepUnusedDataFor,\n        reducerPath,\n        invalidationBehavior\n      }\n    });\n    safeAssign(api.util, {\n      patchQueryData,\n      updateQueryData,\n      upsertQueryData,\n      prefetch,\n      resetApiState: sliceActions.resetApiState,\n      upsertQueryEntries: sliceActions.cacheEntriesUpserted\n    });\n    safeAssign(api.internalActions, sliceActions);\n    const internalStateMap = /* @__PURE__ */ new WeakMap();\n    const getInternalState = (dispatch) => {\n      const state = getOrInsertComputed(internalStateMap, dispatch, () => ({\n        currentSubscriptions: /* @__PURE__ */ new Map(),\n        currentPolls: /* @__PURE__ */ new Map(),\n        runningQueries: /* @__PURE__ */ new Map(),\n        runningMutations: /* @__PURE__ */ new Map()\n      }));\n      return state;\n    };\n    const {\n      buildInitiateQuery,\n      buildInitiateInfiniteQuery,\n      buildInitiateMutation,\n      getRunningMutationThunk,\n      getRunningMutationsThunk,\n      getRunningQueriesThunk,\n      getRunningQueryThunk\n    } = buildInitiate({\n      queryThunk,\n      mutationThunk,\n      infiniteQueryThunk,\n      api,\n      serializeQueryArgs,\n      context,\n      getInternalState\n    });\n    safeAssign(api.util, {\n      getRunningMutationThunk,\n      getRunningMutationsThunk,\n      getRunningQueryThunk,\n      getRunningQueriesThunk\n    });\n    const {\n      middleware,\n      actions: middlewareActions\n    } = buildMiddleware({\n      reducerPath,\n      context,\n      queryThunk,\n      mutationThunk,\n      infiniteQueryThunk,\n      api,\n      assertTagType,\n      selectors,\n      getRunningQueryThunk,\n      getInternalState\n    });\n    safeAssign(api.util, middlewareActions);\n    safeAssign(api, {\n      reducer,\n      middleware\n    });\n    return {\n      name: coreModuleName,\n      injectEndpoint(endpointName, definition) {\n        const anyApi = api;\n        const endpoint = anyApi.endpoints[endpointName] ??= {};\n        if (isQueryDefinition(definition)) {\n          safeAssign(endpoint, {\n            name: endpointName,\n            select: buildQuerySelector(endpointName, definition),\n            initiate: buildInitiateQuery(endpointName, definition)\n          }, buildMatchThunkActions(queryThunk, endpointName));\n        }\n        if (isMutationDefinition(definition)) {\n          safeAssign(endpoint, {\n            name: endpointName,\n            select: buildMutationSelector(),\n            initiate: buildInitiateMutation(endpointName)\n          }, buildMatchThunkActions(mutationThunk, endpointName));\n        }\n        if (isInfiniteQueryDefinition(definition)) {\n          safeAssign(endpoint, {\n            name: endpointName,\n            select: buildInfiniteQuerySelector(endpointName, definition),\n            initiate: buildInitiateInfiniteQuery(endpointName, definition)\n          }, buildMatchThunkActions(queryThunk, endpointName));\n        }\n      }\n    };\n  }\n});\n\n// src/query/core/index.ts\nvar createApi = /* @__PURE__ */ buildCreateApi(coreModule());\nexport {\n  NamedSchemaError,\n  QueryStatus,\n  _NEVER,\n  buildCreateApi,\n  copyWithStructuralSharing,\n  coreModule,\n  coreModuleName,\n  createApi,\n  defaultSerializeQueryArgs,\n  fakeBaseQuery,\n  fetchBaseQuery,\n  retry,\n  setupListeners,\n  skipToken\n};\n//# sourceMappingURL=rtk-query.modern.mjs.map","// src/query/react/rtkqImports.ts\nimport { buildCreateApi, coreModule, copyWithStructuralSharing, setupListeners, QueryStatus, skipToken } from \"@reduxjs/toolkit/query\";\n\n// src/query/react/module.ts\nimport { formatProdErrorMessage as _formatProdErrorMessage3 } from \"@reduxjs/toolkit\";\nimport { batch as rrBatch, useDispatch as rrUseDispatch, useSelector as rrUseSelector, useStore as rrUseStore } from \"react-redux\";\nimport { createSelector as _createSelector } from \"reselect\";\n\n// src/query/utils/capitalize.ts\nfunction capitalize(str) {\n  return str.replace(str[0], str[0].toUpperCase());\n}\n\n// src/query/utils/countObjectKeys.ts\nfunction countObjectKeys(obj) {\n  let count = 0;\n  for (const _key in obj) {\n    count++;\n  }\n  return count;\n}\n\n// src/query/endpointDefinitions.ts\nvar ENDPOINT_QUERY = \"query\" /* query */;\nvar ENDPOINT_MUTATION = \"mutation\" /* mutation */;\nvar ENDPOINT_INFINITEQUERY = \"infinitequery\" /* infinitequery */;\nfunction isQueryDefinition(e) {\n  return e.type === ENDPOINT_QUERY;\n}\nfunction isMutationDefinition(e) {\n  return e.type === ENDPOINT_MUTATION;\n}\nfunction isInfiniteQueryDefinition(e) {\n  return e.type === ENDPOINT_INFINITEQUERY;\n}\n\n// src/query/tsHelpers.ts\nfunction safeAssign(target, ...args) {\n  return Object.assign(target, ...args);\n}\n\n// src/query/react/buildHooks.ts\nimport { formatProdErrorMessage as _formatProdErrorMessage, formatProdErrorMessage as _formatProdErrorMessage2 } from \"@reduxjs/toolkit\";\n\n// src/query/react/reactImports.ts\nimport { useEffect, useRef, useMemo, useContext, useCallback, useDebugValue, useLayoutEffect, useState } from \"react\";\n\n// src/query/react/reactReduxImports.ts\nimport { shallowEqual, Provider, ReactReduxContext } from \"react-redux\";\n\n// src/query/react/constants.ts\nvar UNINITIALIZED_VALUE = Symbol();\n\n// src/query/react/useSerializedStableValue.ts\nfunction useStableQueryArgs(queryArgs) {\n  const cache = useRef(queryArgs);\n  const copy = useMemo(() => copyWithStructuralSharing(cache.current, queryArgs), [queryArgs]);\n  useEffect(() => {\n    if (cache.current !== copy) {\n      cache.current = copy;\n    }\n  }, [copy]);\n  return copy;\n}\n\n// src/query/react/useShallowStableValue.ts\nfunction useShallowStableValue(value) {\n  const cache = useRef(value);\n  useEffect(() => {\n    if (!shallowEqual(cache.current, value)) {\n      cache.current = value;\n    }\n  }, [value]);\n  return shallowEqual(cache.current, value) ? cache.current : value;\n}\n\n// src/query/react/buildHooks.ts\nvar canUseDOM = () => !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\nvar isDOM = /* @__PURE__ */ canUseDOM();\nvar isRunningInReactNative = () => typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\";\nvar isReactNative = /* @__PURE__ */ isRunningInReactNative();\nvar getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? useLayoutEffect : useEffect;\nvar useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();\nvar noPendingQueryStateSelector = (selected) => {\n  if (selected.isUninitialized) {\n    return {\n      ...selected,\n      isUninitialized: false,\n      isFetching: true,\n      isLoading: selected.data !== void 0 ? false : true,\n      // This is the one place where we still have to use `QueryStatus` as an enum,\n      // since it's the only reference in the React package and not in the core.\n      status: QueryStatus.pending\n    };\n  }\n  return selected;\n};\nfunction pick(obj, ...keys) {\n  const ret = {};\n  keys.forEach((key) => {\n    ret[key] = obj[key];\n  });\n  return ret;\n}\nvar COMMON_HOOK_DEBUG_FIELDS = [\"data\", \"status\", \"isLoading\", \"isSuccess\", \"isError\", \"error\"];\nfunction buildHooks({\n  api,\n  moduleOptions: {\n    batch,\n    hooks: {\n      useDispatch,\n      useSelector,\n      useStore\n    },\n    unstable__sideEffectsInRender,\n    createSelector\n  },\n  serializeQueryArgs,\n  context\n}) {\n  const usePossiblyImmediateEffect = unstable__sideEffectsInRender ? (cb) => cb() : useEffect;\n  const unsubscribePromiseRef = (ref) => ref.current?.unsubscribe?.();\n  const endpointDefinitions = context.endpointDefinitions;\n  return {\n    buildQueryHooks,\n    buildInfiniteQueryHooks,\n    buildMutationHook,\n    usePrefetch\n  };\n  function queryStatePreSelector(currentState, lastResult, queryArgs) {\n    if (lastResult?.endpointName && currentState.isUninitialized) {\n      const {\n        endpointName\n      } = lastResult;\n      const endpointDefinition = endpointDefinitions[endpointName];\n      if (queryArgs !== skipToken && serializeQueryArgs({\n        queryArgs: lastResult.originalArgs,\n        endpointDefinition,\n        endpointName\n      }) === serializeQueryArgs({\n        queryArgs,\n        endpointDefinition,\n        endpointName\n      })) lastResult = void 0;\n    }\n    let data = currentState.isSuccess ? currentState.data : lastResult?.data;\n    if (data === void 0) data = currentState.data;\n    const hasData = data !== void 0;\n    const isFetching = currentState.isLoading;\n    const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;\n    const isSuccess = currentState.isSuccess || hasData && (isFetching && !lastResult?.isError || currentState.isUninitialized);\n    return {\n      ...currentState,\n      data,\n      currentData: currentState.data,\n      isFetching,\n      isLoading,\n      isSuccess\n    };\n  }\n  function infiniteQueryStatePreSelector(currentState, lastResult, queryArgs) {\n    if (lastResult?.endpointName && currentState.isUninitialized) {\n      const {\n        endpointName\n      } = lastResult;\n      const endpointDefinition = endpointDefinitions[endpointName];\n      if (queryArgs !== skipToken && serializeQueryArgs({\n        queryArgs: lastResult.originalArgs,\n        endpointDefinition,\n        endpointName\n      }) === serializeQueryArgs({\n        queryArgs,\n        endpointDefinition,\n        endpointName\n      })) lastResult = void 0;\n    }\n    let data = currentState.isSuccess ? currentState.data : lastResult?.data;\n    if (data === void 0) data = currentState.data;\n    const hasData = data !== void 0;\n    const isFetching = currentState.isLoading;\n    const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;\n    const isSuccess = currentState.isSuccess || isFetching && hasData;\n    return {\n      ...currentState,\n      data,\n      currentData: currentState.data,\n      isFetching,\n      isLoading,\n      isSuccess\n    };\n  }\n  function usePrefetch(endpointName, defaultOptions) {\n    const dispatch = useDispatch();\n    const stableDefaultOptions = useShallowStableValue(defaultOptions);\n    return useCallback((arg, options) => dispatch(api.util.prefetch(endpointName, arg, {\n      ...stableDefaultOptions,\n      ...options\n    })), [endpointName, dispatch, stableDefaultOptions]);\n  }\n  function useQuerySubscriptionCommonImpl(endpointName, arg, {\n    refetchOnReconnect,\n    refetchOnFocus,\n    refetchOnMountOrArgChange,\n    skip = false,\n    pollingInterval = 0,\n    skipPollingIfUnfocused = false,\n    ...rest\n  } = {}) {\n    const {\n      initiate\n    } = api.endpoints[endpointName];\n    const dispatch = useDispatch();\n    const subscriptionSelectorsRef = useRef(void 0);\n    if (!subscriptionSelectorsRef.current) {\n      const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());\n      if (process.env.NODE_ENV !== \"production\") {\n        if (typeof returnedValue !== \"object\" || typeof returnedValue?.type === \"string\") {\n          throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage(37) : `Warning: Middleware for RTK-Query API at reducerPath \"${api.reducerPath}\" has not been added to the store.\n    You must add the middleware for RTK-Query to function correctly!`);\n        }\n      }\n      subscriptionSelectorsRef.current = returnedValue;\n    }\n    const stableArg = useStableQueryArgs(skip ? skipToken : arg);\n    const stableSubscriptionOptions = useShallowStableValue({\n      refetchOnReconnect,\n      refetchOnFocus,\n      pollingInterval,\n      skipPollingIfUnfocused\n    });\n    const initialPageParam = rest.initialPageParam;\n    const stableInitialPageParam = useShallowStableValue(initialPageParam);\n    const promiseRef = useRef(void 0);\n    let {\n      queryCacheKey,\n      requestId\n    } = promiseRef.current || {};\n    let currentRenderHasSubscription = false;\n    if (queryCacheKey && requestId) {\n      currentRenderHasSubscription = subscriptionSelectorsRef.current.isRequestSubscribed(queryCacheKey, requestId);\n    }\n    const subscriptionRemoved = !currentRenderHasSubscription && promiseRef.current !== void 0;\n    usePossiblyImmediateEffect(() => {\n      if (subscriptionRemoved) {\n        promiseRef.current = void 0;\n      }\n    }, [subscriptionRemoved]);\n    usePossiblyImmediateEffect(() => {\n      const lastPromise = promiseRef.current;\n      if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"removeMeOnCompilation\") {\n        console.log(subscriptionRemoved);\n      }\n      if (stableArg === skipToken) {\n        lastPromise?.unsubscribe();\n        promiseRef.current = void 0;\n        return;\n      }\n      const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;\n      if (!lastPromise || lastPromise.arg !== stableArg) {\n        lastPromise?.unsubscribe();\n        const promise = dispatch(initiate(stableArg, {\n          subscriptionOptions: stableSubscriptionOptions,\n          forceRefetch: refetchOnMountOrArgChange,\n          ...isInfiniteQueryDefinition(endpointDefinitions[endpointName]) ? {\n            initialPageParam: stableInitialPageParam\n          } : {}\n        }));\n        promiseRef.current = promise;\n      } else if (stableSubscriptionOptions !== lastSubscriptionOptions) {\n        lastPromise.updateSubscriptionOptions(stableSubscriptionOptions);\n      }\n    }, [dispatch, initiate, refetchOnMountOrArgChange, stableArg, stableSubscriptionOptions, subscriptionRemoved, stableInitialPageParam, endpointName]);\n    return [promiseRef, dispatch, initiate, stableSubscriptionOptions];\n  }\n  function buildUseQueryState(endpointName, preSelector) {\n    const useQueryState = (arg, {\n      skip = false,\n      selectFromResult\n    } = {}) => {\n      const {\n        select\n      } = api.endpoints[endpointName];\n      const stableArg = useStableQueryArgs(skip ? skipToken : arg);\n      const lastValue = useRef(void 0);\n      const selectDefaultResult = useMemo(() => (\n        // Normally ts-ignores are bad and should be avoided, but we're\n        // already casting this selector to be `Selector<any>` anyway,\n        // so the inconsistencies don't matter here\n        // @ts-ignore\n        createSelector([\n          // @ts-ignore\n          select(stableArg),\n          (_, lastResult) => lastResult,\n          (_) => stableArg\n        ], preSelector, {\n          memoizeOptions: {\n            resultEqualityCheck: shallowEqual\n          }\n        })\n      ), [select, stableArg]);\n      const querySelector = useMemo(() => selectFromResult ? createSelector([selectDefaultResult], selectFromResult, {\n        devModeChecks: {\n          identityFunctionCheck: \"never\"\n        }\n      }) : selectDefaultResult, [selectDefaultResult, selectFromResult]);\n      const currentState = useSelector((state) => querySelector(state, lastValue.current), shallowEqual);\n      const store = useStore();\n      const newLastValue = selectDefaultResult(store.getState(), lastValue.current);\n      useIsomorphicLayoutEffect(() => {\n        lastValue.current = newLastValue;\n      }, [newLastValue]);\n      return currentState;\n    };\n    return useQueryState;\n  }\n  function usePromiseRefUnsubscribeOnUnmount(promiseRef) {\n    useEffect(() => {\n      return () => {\n        unsubscribePromiseRef(promiseRef);\n        promiseRef.current = void 0;\n      };\n    }, [promiseRef]);\n  }\n  function refetchOrErrorIfUnmounted(promiseRef) {\n    if (!promiseRef.current) throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage2(38) : \"Cannot refetch a query that has not been started yet.\");\n    return promiseRef.current.refetch();\n  }\n  function buildQueryHooks(endpointName) {\n    const useQuerySubscription = (arg, options = {}) => {\n      const [promiseRef] = useQuerySubscriptionCommonImpl(endpointName, arg, options);\n      usePromiseRefUnsubscribeOnUnmount(promiseRef);\n      return useMemo(() => ({\n        /**\n         * A method to manually refetch data for the query\n         */\n        refetch: () => refetchOrErrorIfUnmounted(promiseRef)\n      }), [promiseRef]);\n    };\n    const useLazyQuerySubscription = ({\n      refetchOnReconnect,\n      refetchOnFocus,\n      pollingInterval = 0,\n      skipPollingIfUnfocused = false\n    } = {}) => {\n      const {\n        initiate\n      } = api.endpoints[endpointName];\n      const dispatch = useDispatch();\n      const [arg, setArg] = useState(UNINITIALIZED_VALUE);\n      const promiseRef = useRef(void 0);\n      const stableSubscriptionOptions = useShallowStableValue({\n        refetchOnReconnect,\n        refetchOnFocus,\n        pollingInterval,\n        skipPollingIfUnfocused\n      });\n      usePossiblyImmediateEffect(() => {\n        const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;\n        if (stableSubscriptionOptions !== lastSubscriptionOptions) {\n          promiseRef.current?.updateSubscriptionOptions(stableSubscriptionOptions);\n        }\n      }, [stableSubscriptionOptions]);\n      const subscriptionOptionsRef = useRef(stableSubscriptionOptions);\n      usePossiblyImmediateEffect(() => {\n        subscriptionOptionsRef.current = stableSubscriptionOptions;\n      }, [stableSubscriptionOptions]);\n      const trigger = useCallback(function(arg2, preferCacheValue = false) {\n        let promise;\n        batch(() => {\n          unsubscribePromiseRef(promiseRef);\n          promiseRef.current = promise = dispatch(initiate(arg2, {\n            subscriptionOptions: subscriptionOptionsRef.current,\n            forceRefetch: !preferCacheValue\n          }));\n          setArg(arg2);\n        });\n        return promise;\n      }, [dispatch, initiate]);\n      const reset = useCallback(() => {\n        if (promiseRef.current?.queryCacheKey) {\n          dispatch(api.internalActions.removeQueryResult({\n            queryCacheKey: promiseRef.current?.queryCacheKey\n          }));\n        }\n      }, [dispatch]);\n      useEffect(() => {\n        return () => {\n          unsubscribePromiseRef(promiseRef);\n        };\n      }, []);\n      useEffect(() => {\n        if (arg !== UNINITIALIZED_VALUE && !promiseRef.current) {\n          trigger(arg, true);\n        }\n      }, [arg, trigger]);\n      return useMemo(() => [trigger, arg, {\n        reset\n      }], [trigger, arg, reset]);\n    };\n    const useQueryState = buildUseQueryState(endpointName, queryStatePreSelector);\n    return {\n      useQueryState,\n      useQuerySubscription,\n      useLazyQuerySubscription,\n      useLazyQuery(options) {\n        const [trigger, arg, {\n          reset\n        }] = useLazyQuerySubscription(options);\n        const queryStateResults = useQueryState(arg, {\n          ...options,\n          skip: arg === UNINITIALIZED_VALUE\n        });\n        const info = useMemo(() => ({\n          lastArg: arg\n        }), [arg]);\n        return useMemo(() => [trigger, {\n          ...queryStateResults,\n          reset\n        }, info], [trigger, queryStateResults, reset, info]);\n      },\n      useQuery(arg, options) {\n        const querySubscriptionResults = useQuerySubscription(arg, options);\n        const queryStateResults = useQueryState(arg, {\n          selectFromResult: arg === skipToken || options?.skip ? void 0 : noPendingQueryStateSelector,\n          ...options\n        });\n        const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS);\n        useDebugValue(debugValue);\n        return useMemo(() => ({\n          ...queryStateResults,\n          ...querySubscriptionResults\n        }), [queryStateResults, querySubscriptionResults]);\n      }\n    };\n  }\n  function buildInfiniteQueryHooks(endpointName) {\n    const useInfiniteQuerySubscription = (arg, options = {}) => {\n      const [promiseRef, dispatch, initiate, stableSubscriptionOptions] = useQuerySubscriptionCommonImpl(endpointName, arg, options);\n      const subscriptionOptionsRef = useRef(stableSubscriptionOptions);\n      usePossiblyImmediateEffect(() => {\n        subscriptionOptionsRef.current = stableSubscriptionOptions;\n      }, [stableSubscriptionOptions]);\n      const trigger = useCallback(function(arg2, direction) {\n        let promise;\n        batch(() => {\n          unsubscribePromiseRef(promiseRef);\n          promiseRef.current = promise = dispatch(initiate(arg2, {\n            subscriptionOptions: subscriptionOptionsRef.current,\n            direction\n          }));\n        });\n        return promise;\n      }, [promiseRef, dispatch, initiate]);\n      usePromiseRefUnsubscribeOnUnmount(promiseRef);\n      const stableArg = useStableQueryArgs(options.skip ? skipToken : arg);\n      const refetch = useCallback(() => refetchOrErrorIfUnmounted(promiseRef), [promiseRef]);\n      return useMemo(() => {\n        const fetchNextPage = () => {\n          return trigger(stableArg, \"forward\");\n        };\n        const fetchPreviousPage = () => {\n          return trigger(stableArg, \"backward\");\n        };\n        return {\n          trigger,\n          /**\n           * A method to manually refetch data for the query\n           */\n          refetch,\n          fetchNextPage,\n          fetchPreviousPage\n        };\n      }, [refetch, trigger, stableArg]);\n    };\n    const useInfiniteQueryState = buildUseQueryState(endpointName, infiniteQueryStatePreSelector);\n    return {\n      useInfiniteQueryState,\n      useInfiniteQuerySubscription,\n      useInfiniteQuery(arg, options) {\n        const {\n          refetch,\n          fetchNextPage,\n          fetchPreviousPage\n        } = useInfiniteQuerySubscription(arg, options);\n        const queryStateResults = useInfiniteQueryState(arg, {\n          selectFromResult: arg === skipToken || options?.skip ? void 0 : noPendingQueryStateSelector,\n          ...options\n        });\n        const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS, \"hasNextPage\", \"hasPreviousPage\");\n        useDebugValue(debugValue);\n        return useMemo(() => ({\n          ...queryStateResults,\n          fetchNextPage,\n          fetchPreviousPage,\n          refetch\n        }), [queryStateResults, fetchNextPage, fetchPreviousPage, refetch]);\n      }\n    };\n  }\n  function buildMutationHook(name) {\n    return ({\n      selectFromResult,\n      fixedCacheKey\n    } = {}) => {\n      const {\n        select,\n        initiate\n      } = api.endpoints[name];\n      const dispatch = useDispatch();\n      const [promise, setPromise] = useState();\n      useEffect(() => () => {\n        if (!promise?.arg.fixedCacheKey) {\n          promise?.reset();\n        }\n      }, [promise]);\n      const triggerMutation = useCallback(function(arg) {\n        const promise2 = dispatch(initiate(arg, {\n          fixedCacheKey\n        }));\n        setPromise(promise2);\n        return promise2;\n      }, [dispatch, initiate, fixedCacheKey]);\n      const {\n        requestId\n      } = promise || {};\n      const selectDefaultResult = useMemo(() => select({\n        fixedCacheKey,\n        requestId: promise?.requestId\n      }), [fixedCacheKey, promise, select]);\n      const mutationSelector = useMemo(() => selectFromResult ? createSelector([selectDefaultResult], selectFromResult) : selectDefaultResult, [selectFromResult, selectDefaultResult]);\n      const currentState = useSelector(mutationSelector, shallowEqual);\n      const originalArgs = fixedCacheKey == null ? promise?.arg.originalArgs : void 0;\n      const reset = useCallback(() => {\n        batch(() => {\n          if (promise) {\n            setPromise(void 0);\n          }\n          if (fixedCacheKey) {\n            dispatch(api.internalActions.removeMutationResult({\n              requestId,\n              fixedCacheKey\n            }));\n          }\n        });\n      }, [dispatch, fixedCacheKey, promise, requestId]);\n      const debugValue = pick(currentState, ...COMMON_HOOK_DEBUG_FIELDS, \"endpointName\");\n      useDebugValue(debugValue);\n      const finalState = useMemo(() => ({\n        ...currentState,\n        originalArgs,\n        reset\n      }), [currentState, originalArgs, reset]);\n      return useMemo(() => [triggerMutation, finalState], [triggerMutation, finalState]);\n    };\n  }\n}\n\n// src/query/react/module.ts\nvar reactHooksModuleName = /* @__PURE__ */ Symbol();\nvar reactHooksModule = ({\n  batch = rrBatch,\n  hooks = {\n    useDispatch: rrUseDispatch,\n    useSelector: rrUseSelector,\n    useStore: rrUseStore\n  },\n  createSelector = _createSelector,\n  unstable__sideEffectsInRender = false,\n  ...rest\n} = {}) => {\n  if (process.env.NODE_ENV !== \"production\") {\n    const hookNames = [\"useDispatch\", \"useSelector\", \"useStore\"];\n    let warned = false;\n    for (const hookName of hookNames) {\n      if (countObjectKeys(rest) > 0) {\n        if (rest[hookName]) {\n          if (!warned) {\n            console.warn(\"As of RTK 2.0, the hooks now need to be specified as one object, provided under a `hooks` key:\\n`reactHooksModule({ hooks: { useDispatch, useSelector, useStore } })`\");\n            warned = true;\n          }\n        }\n        hooks[hookName] = rest[hookName];\n      }\n      if (typeof hooks[hookName] !== \"function\") {\n        throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage3(36) : `When using custom hooks for context, all ${hookNames.length} hooks need to be provided: ${hookNames.join(\", \")}.\nHook ${hookName} was either not provided or not a function.`);\n      }\n    }\n  }\n  return {\n    name: reactHooksModuleName,\n    init(api, {\n      serializeQueryArgs\n    }, context) {\n      const anyApi = api;\n      const {\n        buildQueryHooks,\n        buildInfiniteQueryHooks,\n        buildMutationHook,\n        usePrefetch\n      } = buildHooks({\n        api,\n        moduleOptions: {\n          batch,\n          hooks,\n          unstable__sideEffectsInRender,\n          createSelector\n        },\n        serializeQueryArgs,\n        context\n      });\n      safeAssign(anyApi, {\n        usePrefetch\n      });\n      safeAssign(context, {\n        batch\n      });\n      return {\n        injectEndpoint(endpointName, definition) {\n          if (isQueryDefinition(definition)) {\n            const {\n              useQuery,\n              useLazyQuery,\n              useLazyQuerySubscription,\n              useQueryState,\n              useQuerySubscription\n            } = buildQueryHooks(endpointName);\n            safeAssign(anyApi.endpoints[endpointName], {\n              useQuery,\n              useLazyQuery,\n              useLazyQuerySubscription,\n              useQueryState,\n              useQuerySubscription\n            });\n            api[`use${capitalize(endpointName)}Query`] = useQuery;\n            api[`useLazy${capitalize(endpointName)}Query`] = useLazyQuery;\n          }\n          if (isMutationDefinition(definition)) {\n            const useMutation = buildMutationHook(endpointName);\n            safeAssign(anyApi.endpoints[endpointName], {\n              useMutation\n            });\n            api[`use${capitalize(endpointName)}Mutation`] = useMutation;\n          } else if (isInfiniteQueryDefinition(definition)) {\n            const {\n              useInfiniteQuery,\n              useInfiniteQuerySubscription,\n              useInfiniteQueryState\n            } = buildInfiniteQueryHooks(endpointName);\n            safeAssign(anyApi.endpoints[endpointName], {\n              useInfiniteQuery,\n              useInfiniteQuerySubscription,\n              useInfiniteQueryState\n            });\n            api[`use${capitalize(endpointName)}InfiniteQuery`] = useInfiniteQuery;\n          }\n        }\n      };\n    }\n  };\n};\n\n// src/query/react/index.ts\nexport * from \"@reduxjs/toolkit/query\";\n\n// src/query/react/ApiProvider.tsx\nimport { configureStore, formatProdErrorMessage as _formatProdErrorMessage4 } from \"@reduxjs/toolkit\";\nimport * as React from \"react\";\nfunction ApiProvider(props) {\n  const context = props.context || ReactReduxContext;\n  const existingContext = useContext(context);\n  if (existingContext) {\n    throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage4(35) : \"Existing Redux context detected. If you already have a store set up, please use the traditional Redux setup.\");\n  }\n  const [store] = React.useState(() => configureStore({\n    reducer: {\n      [props.api.reducerPath]: props.api.reducer\n    },\n    middleware: (gDM) => gDM().concat(props.api.middleware)\n  }));\n  useEffect(() => props.setupListeners === false ? void 0 : setupListeners(store.dispatch, props.setupListeners), [props.setupListeners, store.dispatch]);\n  return /* @__PURE__ */ React.createElement(Provider, { store, context }, props.children);\n}\n\n// src/query/react/index.ts\nvar createApi = /* @__PURE__ */ buildCreateApi(coreModule(), reactHooksModule());\nexport {\n  ApiProvider,\n  UNINITIALIZED_VALUE,\n  createApi,\n  reactHooksModule,\n  reactHooksModuleName\n};\n//# sourceMappingURL=rtk-query-react.modern.mjs.map"],"mappings":"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"}